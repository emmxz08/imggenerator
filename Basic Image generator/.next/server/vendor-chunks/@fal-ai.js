"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@fal-ai";
exports.ids = ["vendor-chunks/@fal-ai"];
exports.modules = {

/***/ "(rsc)/./node_modules/@fal-ai/client/src/auth.js":
/*!*************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/auth.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TOKEN_EXPIRATION_SECONDS = void 0;\nexports.getTemporaryAuthToken = getTemporaryAuthToken;\nconst config_1 = __webpack_require__(/*! ./config */ \"(rsc)/./node_modules/@fal-ai/client/src/config.js\");\nconst request_1 = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/@fal-ai/client/src/request.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@fal-ai/client/src/utils.js\");\nexports.TOKEN_EXPIRATION_SECONDS = 120;\n/**\n * Get a token to connect to the realtime endpoint.\n */\nfunction getTemporaryAuthToken(app, config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const appId = (0, utils_1.parseEndpointId)(app);\n        const token = yield (0, request_1.dispatchRequest)({\n            method: \"POST\",\n            targetUrl: `${(0, config_1.getRestApiUrl)()}/tokens/`,\n            config,\n            input: {\n                allowed_apps: [appId.alias],\n                token_expiration: exports.TOKEN_EXPIRATION_SECONDS,\n            },\n        });\n        // keep this in case the response was wrapped (old versions of the proxy do that)\n        // should be safe to remove in the future\n        if (typeof token !== \"string\" && token[\"detail\"]) {\n            return token[\"detail\"];\n        }\n        return token;\n    });\n}\n//# sourceMappingURL=auth.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL2F1dGguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQztBQUNoQyw2QkFBNkI7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsbUVBQVU7QUFDbkMsa0JBQWtCLG1CQUFPLENBQUMscUVBQVc7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQVM7QUFDakMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbXBsYXRlLTIvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL2F1dGguanM/NzQzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UT0tFTl9FWFBJUkFUSU9OX1NFQ09ORFMgPSB2b2lkIDA7XG5leHBvcnRzLmdldFRlbXBvcmFyeUF1dGhUb2tlbiA9IGdldFRlbXBvcmFyeUF1dGhUb2tlbjtcbmNvbnN0IGNvbmZpZ18xID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuY29uc3QgcmVxdWVzdF8xID0gcmVxdWlyZShcIi4vcmVxdWVzdFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMuVE9LRU5fRVhQSVJBVElPTl9TRUNPTkRTID0gMTIwO1xuLyoqXG4gKiBHZXQgYSB0b2tlbiB0byBjb25uZWN0IHRvIHRoZSByZWFsdGltZSBlbmRwb2ludC5cbiAqL1xuZnVuY3Rpb24gZ2V0VGVtcG9yYXJ5QXV0aFRva2VuKGFwcCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgYXBwSWQgPSAoMCwgdXRpbHNfMS5wYXJzZUVuZHBvaW50SWQpKGFwcCk7XG4gICAgICAgIGNvbnN0IHRva2VuID0geWllbGQgKDAsIHJlcXVlc3RfMS5kaXNwYXRjaFJlcXVlc3QpKHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICB0YXJnZXRVcmw6IGAkeygwLCBjb25maWdfMS5nZXRSZXN0QXBpVXJsKSgpfS90b2tlbnMvYCxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgICAgYWxsb3dlZF9hcHBzOiBbYXBwSWQuYWxpYXNdLFxuICAgICAgICAgICAgICAgIHRva2VuX2V4cGlyYXRpb246IGV4cG9ydHMuVE9LRU5fRVhQSVJBVElPTl9TRUNPTkRTLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGtlZXAgdGhpcyBpbiBjYXNlIHRoZSByZXNwb25zZSB3YXMgd3JhcHBlZCAob2xkIHZlcnNpb25zIG9mIHRoZSBwcm94eSBkbyB0aGF0KVxuICAgICAgICAvLyBzaG91bGQgYmUgc2FmZSB0byByZW1vdmUgaW4gdGhlIGZ1dHVyZVxuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSBcInN0cmluZ1wiICYmIHRva2VuW1wiZGV0YWlsXCJdKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5bXCJkZXRhaWxcIl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/auth.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/client.js":
/*!***************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/client.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createFalClient = createFalClient;\nconst config_1 = __webpack_require__(/*! ./config */ \"(rsc)/./node_modules/@fal-ai/client/src/config.js\");\nconst queue_1 = __webpack_require__(/*! ./queue */ \"(rsc)/./node_modules/@fal-ai/client/src/queue.js\");\nconst realtime_1 = __webpack_require__(/*! ./realtime */ \"(rsc)/./node_modules/@fal-ai/client/src/realtime.js\");\nconst request_1 = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/@fal-ai/client/src/request.js\");\nconst response_1 = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/@fal-ai/client/src/response.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(rsc)/./node_modules/@fal-ai/client/src/storage.js\");\nconst streaming_1 = __webpack_require__(/*! ./streaming */ \"(rsc)/./node_modules/@fal-ai/client/src/streaming.js\");\n/**\n * Creates a new reference of the `FalClient`.\n * @param userConfig Optional configuration to override the default settings.\n * @returns a new instance of the `FalClient`.\n */\nfunction createFalClient(userConfig = {}) {\n    const config = (0, config_1.createConfig)(userConfig);\n    const storage = (0, storage_1.createStorageClient)({ config });\n    const queue = (0, queue_1.createQueueClient)({ config, storage });\n    const streaming = (0, streaming_1.createStreamingClient)({ config, storage });\n    const realtime = (0, realtime_1.createRealtimeClient)({ config });\n    return {\n        queue,\n        realtime,\n        storage,\n        streaming,\n        stream: streaming.stream,\n        run(endpointId_1) {\n            return __awaiter(this, arguments, void 0, function* (endpointId, options = {}) {\n                const input = options.input\n                    ? yield storage.transformInput(options.input)\n                    : undefined;\n                return (0, request_1.dispatchRequest)({\n                    method: options.method,\n                    targetUrl: (0, request_1.buildUrl)(endpointId, options),\n                    input: input,\n                    config: Object.assign(Object.assign({}, config), { responseHandler: response_1.resultResponseHandler }),\n                    options: {\n                        signal: options.abortSignal,\n                    },\n                });\n            });\n        },\n        subscribe: (endpointId, options) => __awaiter(this, void 0, void 0, function* () {\n            const { request_id: requestId } = yield queue.submit(endpointId, options);\n            if (options.onEnqueue) {\n                options.onEnqueue(requestId);\n            }\n            yield queue.subscribeToStatus(endpointId, Object.assign({ requestId }, options));\n            return queue.result(endpointId, { requestId });\n        }),\n    };\n}\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLGlCQUFpQixtQkFBTyxDQUFDLG1FQUFVO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLGlFQUFTO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLHVFQUFZO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLHFFQUFXO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLHVFQUFZO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLHFFQUFXO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLHlFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSx5REFBeUQsUUFBUTtBQUNqRSxtREFBbUQsaUJBQWlCO0FBQ3BFLCtEQUErRCxpQkFBaUI7QUFDaEYsNERBQTRELFFBQVE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsYUFBYSxtREFBbUQ7QUFDMUg7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFdBQVc7QUFDakYsOENBQThDLFdBQVc7QUFDekQsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbXBsYXRlLTIvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL2NsaWVudC5qcz84ZDMyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUZhbENsaWVudCA9IGNyZWF0ZUZhbENsaWVudDtcbmNvbnN0IGNvbmZpZ18xID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuY29uc3QgcXVldWVfMSA9IHJlcXVpcmUoXCIuL3F1ZXVlXCIpO1xuY29uc3QgcmVhbHRpbWVfMSA9IHJlcXVpcmUoXCIuL3JlYWx0aW1lXCIpO1xuY29uc3QgcmVxdWVzdF8xID0gcmVxdWlyZShcIi4vcmVxdWVzdFwiKTtcbmNvbnN0IHJlc3BvbnNlXzEgPSByZXF1aXJlKFwiLi9yZXNwb25zZVwiKTtcbmNvbnN0IHN0b3JhZ2VfMSA9IHJlcXVpcmUoXCIuL3N0b3JhZ2VcIik7XG5jb25zdCBzdHJlYW1pbmdfMSA9IHJlcXVpcmUoXCIuL3N0cmVhbWluZ1wiKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyByZWZlcmVuY2Ugb2YgdGhlIGBGYWxDbGllbnRgLlxuICogQHBhcmFtIHVzZXJDb25maWcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBzZXR0aW5ncy5cbiAqIEByZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgRmFsQ2xpZW50YC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmFsQ2xpZW50KHVzZXJDb25maWcgPSB7fSkge1xuICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBjb25maWdfMS5jcmVhdGVDb25maWcpKHVzZXJDb25maWcpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSAoMCwgc3RvcmFnZV8xLmNyZWF0ZVN0b3JhZ2VDbGllbnQpKHsgY29uZmlnIH0pO1xuICAgIGNvbnN0IHF1ZXVlID0gKDAsIHF1ZXVlXzEuY3JlYXRlUXVldWVDbGllbnQpKHsgY29uZmlnLCBzdG9yYWdlIH0pO1xuICAgIGNvbnN0IHN0cmVhbWluZyA9ICgwLCBzdHJlYW1pbmdfMS5jcmVhdGVTdHJlYW1pbmdDbGllbnQpKHsgY29uZmlnLCBzdG9yYWdlIH0pO1xuICAgIGNvbnN0IHJlYWx0aW1lID0gKDAsIHJlYWx0aW1lXzEuY3JlYXRlUmVhbHRpbWVDbGllbnQpKHsgY29uZmlnIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHF1ZXVlLFxuICAgICAgICByZWFsdGltZSxcbiAgICAgICAgc3RvcmFnZSxcbiAgICAgICAgc3RyZWFtaW5nLFxuICAgICAgICBzdHJlYW06IHN0cmVhbWluZy5zdHJlYW0sXG4gICAgICAgIHJ1bihlbmRwb2ludElkXzEpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uKiAoZW5kcG9pbnRJZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBvcHRpb25zLmlucHV0XG4gICAgICAgICAgICAgICAgICAgID8geWllbGQgc3RvcmFnZS50cmFuc2Zvcm1JbnB1dChvcHRpb25zLmlucHV0KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHJlcXVlc3RfMS5kaXNwYXRjaFJlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VXJsOiAoMCwgcmVxdWVzdF8xLmJ1aWxkVXJsKShlbmRwb2ludElkLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwgeyByZXNwb25zZUhhbmRsZXI6IHJlc3BvbnNlXzEucmVzdWx0UmVzcG9uc2VIYW5kbGVyIH0pLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3Vic2NyaWJlOiAoZW5kcG9pbnRJZCwgb3B0aW9ucykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyByZXF1ZXN0X2lkOiByZXF1ZXN0SWQgfSA9IHlpZWxkIHF1ZXVlLnN1Ym1pdChlbmRwb2ludElkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uRW5xdWV1ZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25FbnF1ZXVlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBxdWV1ZS5zdWJzY3JpYmVUb1N0YXR1cyhlbmRwb2ludElkLCBPYmplY3QuYXNzaWduKHsgcmVxdWVzdElkIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIHJldHVybiBxdWV1ZS5yZXN1bHQoZW5kcG9pbnRJZCwgeyByZXF1ZXN0SWQgfSk7XG4gICAgICAgIH0pLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/config.js":
/*!***************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/config.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.credentialsFromEnv = void 0;\nexports.resolveDefaultFetch = resolveDefaultFetch;\nexports.createConfig = createConfig;\nexports.getRestApiUrl = getRestApiUrl;\nconst middleware_1 = __webpack_require__(/*! ./middleware */ \"(rsc)/./node_modules/@fal-ai/client/src/middleware.js\");\nconst response_1 = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/@fal-ai/client/src/response.js\");\nconst runtime_1 = __webpack_require__(/*! ./runtime */ \"(rsc)/./node_modules/@fal-ai/client/src/runtime.js\");\nfunction resolveDefaultFetch() {\n    if (typeof fetch === \"undefined\") {\n        throw new Error(\"Your environment does not support fetch. Please provide your own fetch implementation.\");\n    }\n    return fetch;\n}\n/**\n * Checks if the required FAL environment variables are set.\n *\n * @returns `true` if the required environment variables are set,\n * `false` otherwise.\n */\nfunction hasEnvVariables() {\n    return (typeof process !== \"undefined\" &&\n        process.env &&\n        (typeof process.env.FAL_KEY !== \"undefined\" ||\n            (typeof process.env.FAL_KEY_ID !== \"undefined\" &&\n                typeof process.env.FAL_KEY_SECRET !== \"undefined\")));\n}\nconst credentialsFromEnv = () => {\n    if (!hasEnvVariables()) {\n        return undefined;\n    }\n    if (typeof process.env.FAL_KEY !== \"undefined\") {\n        return process.env.FAL_KEY;\n    }\n    return process.env.FAL_KEY_ID\n        ? `${process.env.FAL_KEY_ID}:${process.env.FAL_KEY_SECRET}`\n        : undefined;\n};\nexports.credentialsFromEnv = credentialsFromEnv;\nconst DEFAULT_CONFIG = {\n    credentials: exports.credentialsFromEnv,\n    suppressLocalCredentialsWarning: false,\n    requestMiddleware: (request) => Promise.resolve(request),\n    responseHandler: response_1.defaultResponseHandler,\n};\n/**\n * Configures the fal client.\n *\n * @param config the new configuration.\n */\nfunction createConfig(config) {\n    var _a;\n    let configuration = Object.assign(Object.assign(Object.assign({}, DEFAULT_CONFIG), config), { fetch: (_a = config.fetch) !== null && _a !== void 0 ? _a : resolveDefaultFetch() });\n    if (config.proxyUrl) {\n        configuration = Object.assign(Object.assign({}, configuration), { requestMiddleware: (0, middleware_1.withMiddleware)(configuration.requestMiddleware, (0, middleware_1.withProxy)({ targetUrl: config.proxyUrl })) });\n    }\n    const { credentials: resolveCredentials, suppressLocalCredentialsWarning } = configuration;\n    const credentials = typeof resolveCredentials === \"function\"\n        ? resolveCredentials()\n        : resolveCredentials;\n    if ((0, runtime_1.isBrowser)() && credentials && !suppressLocalCredentialsWarning) {\n        console.warn(\"The fal credentials are exposed in the browser's environment. \" +\n            \"That's not recommended for production use cases.\");\n    }\n    return configuration;\n}\n/**\n * @returns the URL of the fal REST api endpoint.\n */\nfunction getRestApiUrl() {\n    return \"https://rest.alpha.fal.ai\";\n}\n//# sourceMappingURL=config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL2NvbmZpZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIscUJBQXFCLG1CQUFPLENBQUMsMkVBQWM7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsdUVBQVk7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMscUVBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUIsR0FBRywyQkFBMkI7QUFDbEU7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSw4QkFBOEIsbUZBQW1GO0FBQ3JMO0FBQ0Esc0RBQXNELG9CQUFvQixtSEFBbUgsNEJBQTRCLElBQUk7QUFDN047QUFDQSxZQUFZLG1FQUFtRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbXBsYXRlLTIvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL2NvbmZpZy5qcz9jNGY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVkZW50aWFsc0Zyb21FbnYgPSB2b2lkIDA7XG5leHBvcnRzLnJlc29sdmVEZWZhdWx0RmV0Y2ggPSByZXNvbHZlRGVmYXVsdEZldGNoO1xuZXhwb3J0cy5jcmVhdGVDb25maWcgPSBjcmVhdGVDb25maWc7XG5leHBvcnRzLmdldFJlc3RBcGlVcmwgPSBnZXRSZXN0QXBpVXJsO1xuY29uc3QgbWlkZGxld2FyZV8xID0gcmVxdWlyZShcIi4vbWlkZGxld2FyZVwiKTtcbmNvbnN0IHJlc3BvbnNlXzEgPSByZXF1aXJlKFwiLi9yZXNwb25zZVwiKTtcbmNvbnN0IHJ1bnRpbWVfMSA9IHJlcXVpcmUoXCIuL3J1bnRpbWVcIik7XG5mdW5jdGlvbiByZXNvbHZlRGVmYXVsdEZldGNoKCkge1xuICAgIGlmICh0eXBlb2YgZmV0Y2ggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IGZldGNoLiBQbGVhc2UgcHJvdmlkZSB5b3VyIG93biBmZXRjaCBpbXBsZW1lbnRhdGlvbi5cIik7XG4gICAgfVxuICAgIHJldHVybiBmZXRjaDtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSByZXF1aXJlZCBGQUwgZW52aXJvbm1lbnQgdmFyaWFibGVzIGFyZSBzZXQuXG4gKlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSByZXF1aXJlZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXJlIHNldCxcbiAqIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBoYXNFbnZWYXJpYWJsZXMoKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICBwcm9jZXNzLmVudiAmJlxuICAgICAgICAodHlwZW9mIHByb2Nlc3MuZW52LkZBTF9LRVkgIT09IFwidW5kZWZpbmVkXCIgfHxcbiAgICAgICAgICAgICh0eXBlb2YgcHJvY2Vzcy5lbnYuRkFMX0tFWV9JRCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBwcm9jZXNzLmVudi5GQUxfS0VZX1NFQ1JFVCAhPT0gXCJ1bmRlZmluZWRcIikpKTtcbn1cbmNvbnN0IGNyZWRlbnRpYWxzRnJvbUVudiA9ICgpID0+IHtcbiAgICBpZiAoIWhhc0VudlZhcmlhYmxlcygpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvY2Vzcy5lbnYuRkFMX0tFWSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuRkFMX0tFWTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkZBTF9LRVlfSURcbiAgICAgICAgPyBgJHtwcm9jZXNzLmVudi5GQUxfS0VZX0lEfToke3Byb2Nlc3MuZW52LkZBTF9LRVlfU0VDUkVUfWBcbiAgICAgICAgOiB1bmRlZmluZWQ7XG59O1xuZXhwb3J0cy5jcmVkZW50aWFsc0Zyb21FbnYgPSBjcmVkZW50aWFsc0Zyb21FbnY7XG5jb25zdCBERUZBVUxUX0NPTkZJRyA9IHtcbiAgICBjcmVkZW50aWFsczogZXhwb3J0cy5jcmVkZW50aWFsc0Zyb21FbnYsXG4gICAgc3VwcHJlc3NMb2NhbENyZWRlbnRpYWxzV2FybmluZzogZmFsc2UsXG4gICAgcmVxdWVzdE1pZGRsZXdhcmU6IChyZXF1ZXN0KSA9PiBQcm9taXNlLnJlc29sdmUocmVxdWVzdCksXG4gICAgcmVzcG9uc2VIYW5kbGVyOiByZXNwb25zZV8xLmRlZmF1bHRSZXNwb25zZUhhbmRsZXIsXG59O1xuLyoqXG4gKiBDb25maWd1cmVzIHRoZSBmYWwgY2xpZW50LlxuICpcbiAqIEBwYXJhbSBjb25maWcgdGhlIG5ldyBjb25maWd1cmF0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDb25maWcoY29uZmlnKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBjb25maWd1cmF0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfQ09ORklHKSwgY29uZmlnKSwgeyBmZXRjaDogKF9hID0gY29uZmlnLmZldGNoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiByZXNvbHZlRGVmYXVsdEZldGNoKCkgfSk7XG4gICAgaWYgKGNvbmZpZy5wcm94eVVybCkge1xuICAgICAgICBjb25maWd1cmF0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25maWd1cmF0aW9uKSwgeyByZXF1ZXN0TWlkZGxld2FyZTogKDAsIG1pZGRsZXdhcmVfMS53aXRoTWlkZGxld2FyZSkoY29uZmlndXJhdGlvbi5yZXF1ZXN0TWlkZGxld2FyZSwgKDAsIG1pZGRsZXdhcmVfMS53aXRoUHJveHkpKHsgdGFyZ2V0VXJsOiBjb25maWcucHJveHlVcmwgfSkpIH0pO1xuICAgIH1cbiAgICBjb25zdCB7IGNyZWRlbnRpYWxzOiByZXNvbHZlQ3JlZGVudGlhbHMsIHN1cHByZXNzTG9jYWxDcmVkZW50aWFsc1dhcm5pbmcgfSA9IGNvbmZpZ3VyYXRpb247XG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSB0eXBlb2YgcmVzb2x2ZUNyZWRlbnRpYWxzID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyByZXNvbHZlQ3JlZGVudGlhbHMoKVxuICAgICAgICA6IHJlc29sdmVDcmVkZW50aWFscztcbiAgICBpZiAoKDAsIHJ1bnRpbWVfMS5pc0Jyb3dzZXIpKCkgJiYgY3JlZGVudGlhbHMgJiYgIXN1cHByZXNzTG9jYWxDcmVkZW50aWFsc1dhcm5pbmcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIGZhbCBjcmVkZW50aWFscyBhcmUgZXhwb3NlZCBpbiB0aGUgYnJvd3NlcidzIGVudmlyb25tZW50LiBcIiArXG4gICAgICAgICAgICBcIlRoYXQncyBub3QgcmVjb21tZW5kZWQgZm9yIHByb2R1Y3Rpb24gdXNlIGNhc2VzLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb247XG59XG4vKipcbiAqIEByZXR1cm5zIHRoZSBVUkwgb2YgdGhlIGZhbCBSRVNUIGFwaSBlbmRwb2ludC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVzdEFwaVVybCgpIHtcbiAgICByZXR1cm4gXCJodHRwczovL3Jlc3QuYWxwaGEuZmFsLmFpXCI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maWcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fal = exports.parseEndpointId = exports.ValidationError = exports.ApiError = exports.withProxy = exports.withMiddleware = exports.createFalClient = void 0;\nconst client_1 = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/@fal-ai/client/src/client.js\");\nvar client_2 = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/@fal-ai/client/src/client.js\");\nObject.defineProperty(exports, \"createFalClient\", ({ enumerable: true, get: function () { return client_2.createFalClient; } }));\nvar middleware_1 = __webpack_require__(/*! ./middleware */ \"(rsc)/./node_modules/@fal-ai/client/src/middleware.js\");\nObject.defineProperty(exports, \"withMiddleware\", ({ enumerable: true, get: function () { return middleware_1.withMiddleware; } }));\nObject.defineProperty(exports, \"withProxy\", ({ enumerable: true, get: function () { return middleware_1.withProxy; } }));\nvar response_1 = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/@fal-ai/client/src/response.js\");\nObject.defineProperty(exports, \"ApiError\", ({ enumerable: true, get: function () { return response_1.ApiError; } }));\nObject.defineProperty(exports, \"ValidationError\", ({ enumerable: true, get: function () { return response_1.ValidationError; } }));\n__exportStar(__webpack_require__(/*! ./types/common */ \"(rsc)/./node_modules/@fal-ai/client/src/types/common.js\"), exports);\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@fal-ai/client/src/utils.js\");\nObject.defineProperty(exports, \"parseEndpointId\", ({ enumerable: true, get: function () { return utils_1.parseEndpointId; } }));\n/**\n * Creates a singleton instance of the client. This is useful as a compatibility\n * layer for existing code that uses the clients version prior to 1.0.0.\n */\nexports.fal = (function createSingletonFalClient() {\n    let currentInstance = (0, client_1.createFalClient)();\n    return {\n        config(config) {\n            currentInstance = (0, client_1.createFalClient)(config);\n        },\n        get queue() {\n            return currentInstance.queue;\n        },\n        get realtime() {\n            return currentInstance.realtime;\n        },\n        get storage() {\n            return currentInstance.storage;\n        },\n        get streaming() {\n            return currentInstance.streaming;\n        },\n        run(id, options) {\n            return currentInstance.run(id, options);\n        },\n        subscribe(endpointId, options) {\n            return currentInstance.subscribe(endpointId, options);\n        },\n        stream(endpointId, options) {\n            return currentInstance.stream(endpointId, options);\n        },\n    };\n})();\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVcsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUIsR0FBRyxnQkFBZ0IsR0FBRyxpQkFBaUIsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUI7QUFDekosaUJBQWlCLG1CQUFPLENBQUMsbUVBQVU7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLG1FQUFVO0FBQ2pDLG1EQUFrRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM5SCxtQkFBbUIsbUJBQU8sQ0FBQywyRUFBYztBQUN6QyxrREFBaUQsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDaEksNkNBQTRDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3RILGlCQUFpQixtQkFBTyxDQUFDLHVFQUFZO0FBQ3JDLDRDQUEyQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNsSCxtREFBa0QsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDaEksYUFBYSxtQkFBTyxDQUFDLCtFQUFnQjtBQUNyQyxjQUFjLG1CQUFPLENBQUMsaUVBQVM7QUFDL0IsbURBQWtELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZW1wbGF0ZS0yLy4vbm9kZV9tb2R1bGVzL0BmYWwtYWkvY2xpZW50L3NyYy9pbmRleC5qcz8wZTFkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZhbCA9IGV4cG9ydHMucGFyc2VFbmRwb2ludElkID0gZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSBleHBvcnRzLkFwaUVycm9yID0gZXhwb3J0cy53aXRoUHJveHkgPSBleHBvcnRzLndpdGhNaWRkbGV3YXJlID0gZXhwb3J0cy5jcmVhdGVGYWxDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcbnZhciBjbGllbnRfMiA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZUZhbENsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xpZW50XzIuY3JlYXRlRmFsQ2xpZW50OyB9IH0pO1xudmFyIG1pZGRsZXdhcmVfMSA9IHJlcXVpcmUoXCIuL21pZGRsZXdhcmVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3aXRoTWlkZGxld2FyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWlkZGxld2FyZV8xLndpdGhNaWRkbGV3YXJlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwid2l0aFByb3h5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtaWRkbGV3YXJlXzEud2l0aFByb3h5OyB9IH0pO1xudmFyIHJlc3BvbnNlXzEgPSByZXF1aXJlKFwiLi9yZXNwb25zZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFwaUVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNwb25zZV8xLkFwaUVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFsaWRhdGlvbkVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNwb25zZV8xLlZhbGlkYXRpb25FcnJvcjsgfSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy9jb21tb25cIiksIGV4cG9ydHMpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlRW5kcG9pbnRJZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5wYXJzZUVuZHBvaW50SWQ7IH0gfSk7XG4vKipcbiAqIENyZWF0ZXMgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIGNsaWVudC4gVGhpcyBpcyB1c2VmdWwgYXMgYSBjb21wYXRpYmlsaXR5XG4gKiBsYXllciBmb3IgZXhpc3RpbmcgY29kZSB0aGF0IHVzZXMgdGhlIGNsaWVudHMgdmVyc2lvbiBwcmlvciB0byAxLjAuMC5cbiAqL1xuZXhwb3J0cy5mYWwgPSAoZnVuY3Rpb24gY3JlYXRlU2luZ2xldG9uRmFsQ2xpZW50KCkge1xuICAgIGxldCBjdXJyZW50SW5zdGFuY2UgPSAoMCwgY2xpZW50XzEuY3JlYXRlRmFsQ2xpZW50KSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgICAgIGN1cnJlbnRJbnN0YW5jZSA9ICgwLCBjbGllbnRfMS5jcmVhdGVGYWxDbGllbnQpKGNvbmZpZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBxdWV1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2UucXVldWU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCByZWFsdGltZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2UucmVhbHRpbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzdG9yYWdlKCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnN0YW5jZS5zdG9yYWdlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgc3RyZWFtaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnN0YW5jZS5zdHJlYW1pbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bihpZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnN0YW5jZS5ydW4oaWQsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBzdWJzY3JpYmUoZW5kcG9pbnRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnN0YW5jZS5zdWJzY3JpYmUoZW5kcG9pbnRJZCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmVhbShlbmRwb2ludElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEluc3RhbmNlLnN0cmVhbShlbmRwb2ludElkLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICB9O1xufSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/middleware.js":
/*!*******************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/middleware.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TARGET_URL_HEADER = void 0;\nexports.withMiddleware = withMiddleware;\nexports.withProxy = withProxy;\n/**\n * Setup a execution chain of middleware functions.\n *\n * @param middlewares one or more middleware functions.\n * @returns a middleware function that executes the given middlewares in order.\n */\nfunction withMiddleware(...middlewares) {\n    const isDefined = (middleware) => typeof middleware === \"function\";\n    return (config) => __awaiter(this, void 0, void 0, function* () {\n        let currentConfig = Object.assign({}, config);\n        for (const middleware of middlewares.filter(isDefined)) {\n            currentConfig = yield middleware(currentConfig);\n        }\n        return currentConfig;\n    });\n}\nexports.TARGET_URL_HEADER = \"x-fal-target-url\";\nfunction withProxy(config) {\n    const passthrough = (requestConfig) => Promise.resolve(requestConfig);\n    // when running on the server, we don't need to proxy the request\n    if (typeof window === \"undefined\") {\n        return passthrough;\n    }\n    // if x-fal-target-url is already set, we skip it\n    return (requestConfig) => requestConfig.headers && exports.TARGET_URL_HEADER in requestConfig\n        ? passthrough(requestConfig)\n        : Promise.resolve(Object.assign(Object.assign({}, requestConfig), { url: config.targetUrl, headers: Object.assign(Object.assign({}, (requestConfig.headers || {})), { [exports.TARGET_URL_HEADER]: requestConfig.url }) }));\n}\n//# sourceMappingURL=middleware.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL21pZGRsZXdhcmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsb0JBQW9CLDhEQUE4RCw4QkFBOEIsTUFBTSxnREFBZ0QsR0FBRztBQUNqTztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVtcGxhdGUtMi8uL25vZGVfbW9kdWxlcy9AZmFsLWFpL2NsaWVudC9zcmMvbWlkZGxld2FyZS5qcz8xNWY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRBUkdFVF9VUkxfSEVBREVSID0gdm9pZCAwO1xuZXhwb3J0cy53aXRoTWlkZGxld2FyZSA9IHdpdGhNaWRkbGV3YXJlO1xuZXhwb3J0cy53aXRoUHJveHkgPSB3aXRoUHJveHk7XG4vKipcbiAqIFNldHVwIGEgZXhlY3V0aW9uIGNoYWluIG9mIG1pZGRsZXdhcmUgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSBtaWRkbGV3YXJlcyBvbmUgb3IgbW9yZSBtaWRkbGV3YXJlIGZ1bmN0aW9ucy5cbiAqIEByZXR1cm5zIGEgbWlkZGxld2FyZSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIHRoZSBnaXZlbiBtaWRkbGV3YXJlcyBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gd2l0aE1pZGRsZXdhcmUoLi4ubWlkZGxld2FyZXMpIHtcbiAgICBjb25zdCBpc0RlZmluZWQgPSAobWlkZGxld2FyZSkgPT4gdHlwZW9mIG1pZGRsZXdhcmUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICByZXR1cm4gKGNvbmZpZykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsZXQgY3VycmVudENvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XG4gICAgICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiBtaWRkbGV3YXJlcy5maWx0ZXIoaXNEZWZpbmVkKSkge1xuICAgICAgICAgICAgY3VycmVudENvbmZpZyA9IHlpZWxkIG1pZGRsZXdhcmUoY3VycmVudENvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDb25maWc7XG4gICAgfSk7XG59XG5leHBvcnRzLlRBUkdFVF9VUkxfSEVBREVSID0gXCJ4LWZhbC10YXJnZXQtdXJsXCI7XG5mdW5jdGlvbiB3aXRoUHJveHkoY29uZmlnKSB7XG4gICAgY29uc3QgcGFzc3Rocm91Z2ggPSAocmVxdWVzdENvbmZpZykgPT4gUHJvbWlzZS5yZXNvbHZlKHJlcXVlc3RDb25maWcpO1xuICAgIC8vIHdoZW4gcnVubmluZyBvbiB0aGUgc2VydmVyLCB3ZSBkb24ndCBuZWVkIHRvIHByb3h5IHRoZSByZXF1ZXN0XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhc3N0aHJvdWdoO1xuICAgIH1cbiAgICAvLyBpZiB4LWZhbC10YXJnZXQtdXJsIGlzIGFscmVhZHkgc2V0LCB3ZSBza2lwIGl0XG4gICAgcmV0dXJuIChyZXF1ZXN0Q29uZmlnKSA9PiByZXF1ZXN0Q29uZmlnLmhlYWRlcnMgJiYgZXhwb3J0cy5UQVJHRVRfVVJMX0hFQURFUiBpbiByZXF1ZXN0Q29uZmlnXG4gICAgICAgID8gcGFzc3Rocm91Z2gocmVxdWVzdENvbmZpZylcbiAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0Q29uZmlnKSwgeyB1cmw6IGNvbmZpZy50YXJnZXRVcmwsIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHJlcXVlc3RDb25maWcuaGVhZGVycyB8fCB7fSkpLCB7IFtleHBvcnRzLlRBUkdFVF9VUkxfSEVBREVSXTogcmVxdWVzdENvbmZpZy51cmwgfSkgfSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWlkZGxld2FyZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/middleware.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/queue.js":
/*!**************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/queue.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createQueueClient = void 0;\nconst request_1 = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/@fal-ai/client/src/request.js\");\nconst response_1 = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/@fal-ai/client/src/response.js\");\nconst streaming_1 = __webpack_require__(/*! ./streaming */ \"(rsc)/./node_modules/@fal-ai/client/src/streaming.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@fal-ai/client/src/utils.js\");\nconst DEFAULT_POLL_INTERVAL = 500;\nconst createQueueClient = ({ config, storage, }) => {\n    const ref = {\n        submit(endpointId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const { webhookUrl, priority } = options, runOptions = __rest(options, [\"webhookUrl\", \"priority\"]);\n                const input = options.input\n                    ? yield storage.transformInput(options.input)\n                    : undefined;\n                return (0, request_1.dispatchRequest)({\n                    method: options.method,\n                    targetUrl: (0, request_1.buildUrl)(endpointId, Object.assign(Object.assign({}, runOptions), { subdomain: \"queue\", query: webhookUrl ? { fal_webhook: webhookUrl } : undefined })),\n                    headers: {\n                        \"x-fal-queue-priority\": priority !== null && priority !== void 0 ? priority : \"normal\",\n                    },\n                    input: input,\n                    config,\n                    options: {\n                        signal: options.abortSignal,\n                    },\n                });\n            });\n        },\n        status(endpointId_1, _a) {\n            return __awaiter(this, arguments, void 0, function* (endpointId, { requestId, logs = false, abortSignal }) {\n                const appId = (0, utils_1.parseEndpointId)(endpointId);\n                const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n                return (0, request_1.dispatchRequest)({\n                    method: \"get\",\n                    targetUrl: (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {\n                        subdomain: \"queue\",\n                        query: { logs: logs ? \"1\" : \"0\" },\n                        path: `/requests/${requestId}/status`,\n                    }),\n                    config,\n                    options: {\n                        signal: abortSignal,\n                    },\n                });\n            });\n        },\n        streamStatus(endpointId_1, _a) {\n            return __awaiter(this, arguments, void 0, function* (endpointId, { requestId, logs = false, connectionMode }) {\n                const appId = (0, utils_1.parseEndpointId)(endpointId);\n                const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n                const queryParams = {\n                    logs: logs ? \"1\" : \"0\",\n                };\n                const url = (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {\n                    subdomain: \"queue\",\n                    path: `/requests/${requestId}/status/stream`,\n                    query: queryParams,\n                });\n                return new streaming_1.FalStream(endpointId, config, {\n                    url,\n                    method: \"get\",\n                    connectionMode,\n                    queryParams,\n                });\n            });\n        },\n        subscribeToStatus(endpointId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const requestId = options.requestId;\n                const timeout = options.timeout;\n                let timeoutId = undefined;\n                const handleCancelError = () => {\n                    // Ignore errors as the client will follow through with the timeout\n                    // regardless of the server response. In case cancelation fails, we\n                    // still want to reject the promise and consider the client call canceled.\n                };\n                if (options.mode === \"streaming\") {\n                    const status = yield ref.streamStatus(endpointId, {\n                        requestId,\n                        logs: options.logs,\n                        connectionMode: \"connectionMode\" in options\n                            ? options.connectionMode\n                            : undefined,\n                    });\n                    const logs = [];\n                    if (timeout) {\n                        timeoutId = setTimeout(() => {\n                            status.abort();\n                            ref.cancel(endpointId, { requestId }).catch(handleCancelError);\n                            // TODO this error cannot bubble up to the user since it's thrown in\n                            // a closure in the global scope due to setTimeout behavior.\n                            // User will get a platform error instead. We should find a way to\n                            // make this behavior aligned with polling.\n                            throw new Error(`Client timed out waiting for the request to complete after ${timeout}ms`);\n                        }, timeout);\n                    }\n                    status.on(\"data\", (data) => {\n                        if (options.onQueueUpdate) {\n                            // accumulate logs to match previous polling behavior\n                            if (\"logs\" in data &&\n                                Array.isArray(data.logs) &&\n                                data.logs.length > 0) {\n                                logs.push(...data.logs);\n                            }\n                            options.onQueueUpdate(\"logs\" in data ? Object.assign(Object.assign({}, data), { logs }) : data);\n                        }\n                    });\n                    const doneStatus = yield status.done();\n                    if (timeoutId) {\n                        clearTimeout(timeoutId);\n                    }\n                    return doneStatus;\n                }\n                // default to polling until status streaming is stable and faster\n                return new Promise((resolve, reject) => {\n                    var _a;\n                    let pollingTimeoutId;\n                    // type resolution isn't great in this case, so check for its presence\n                    // and and type so the typechecker behaves as expected\n                    const pollInterval = \"pollInterval\" in options && typeof options.pollInterval === \"number\"\n                        ? ((_a = options.pollInterval) !== null && _a !== void 0 ? _a : DEFAULT_POLL_INTERVAL)\n                        : DEFAULT_POLL_INTERVAL;\n                    const clearScheduledTasks = () => {\n                        if (timeoutId) {\n                            clearTimeout(timeoutId);\n                        }\n                        if (pollingTimeoutId) {\n                            clearTimeout(pollingTimeoutId);\n                        }\n                    };\n                    if (timeout) {\n                        timeoutId = setTimeout(() => {\n                            clearScheduledTasks();\n                            ref.cancel(endpointId, { requestId }).catch(handleCancelError);\n                            reject(new Error(`Client timed out waiting for the request to complete after ${timeout}ms`));\n                        }, timeout);\n                    }\n                    const poll = () => __awaiter(this, void 0, void 0, function* () {\n                        var _a;\n                        try {\n                            const requestStatus = yield ref.status(endpointId, {\n                                requestId,\n                                logs: (_a = options.logs) !== null && _a !== void 0 ? _a : false,\n                                abortSignal: options.abortSignal,\n                            });\n                            if (options.onQueueUpdate) {\n                                options.onQueueUpdate(requestStatus);\n                            }\n                            if (requestStatus.status === \"COMPLETED\") {\n                                clearScheduledTasks();\n                                resolve(requestStatus);\n                                return;\n                            }\n                            pollingTimeoutId = setTimeout(poll, pollInterval);\n                        }\n                        catch (error) {\n                            clearScheduledTasks();\n                            reject(error);\n                        }\n                    });\n                    poll().catch(reject);\n                });\n            });\n        },\n        result(endpointId_1, _a) {\n            return __awaiter(this, arguments, void 0, function* (endpointId, { requestId, abortSignal }) {\n                const appId = (0, utils_1.parseEndpointId)(endpointId);\n                const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n                return (0, request_1.dispatchRequest)({\n                    method: \"get\",\n                    targetUrl: (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {\n                        subdomain: \"queue\",\n                        path: `/requests/${requestId}`,\n                    }),\n                    config: Object.assign(Object.assign({}, config), { responseHandler: response_1.resultResponseHandler }),\n                    options: {\n                        signal: abortSignal,\n                    },\n                });\n            });\n        },\n        cancel(endpointId_1, _a) {\n            return __awaiter(this, arguments, void 0, function* (endpointId, { requestId, abortSignal }) {\n                const appId = (0, utils_1.parseEndpointId)(endpointId);\n                const prefix = appId.namespace ? `${appId.namespace}/` : \"\";\n                yield (0, request_1.dispatchRequest)({\n                    method: \"put\",\n                    targetUrl: (0, request_1.buildUrl)(`${prefix}${appId.owner}/${appId.alias}`, {\n                        subdomain: \"queue\",\n                        path: `/requests/${requestId}/cancel`,\n                    }),\n                    config,\n                    options: {\n                        signal: abortSignal,\n                    },\n                });\n            });\n        },\n    };\n    return ref;\n};\nexports.createQueueClient = createQueueClient;\n//# sourceMappingURL=queue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3F1ZXVlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QixrQkFBa0IsbUJBQU8sQ0FBQyxxRUFBVztBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyx1RUFBWTtBQUN2QyxvQkFBb0IsbUJBQU8sQ0FBQyx5RUFBYTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBUztBQUNqQztBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGlCQUFpQiwwQ0FBMEMsMEJBQTBCLGFBQWE7QUFDbk07QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLCtFQUErRSxzQ0FBc0M7QUFDckg7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQSwwREFBMEQsT0FBTyxFQUFFLFlBQVksR0FBRyxZQUFZO0FBQzlGO0FBQ0EsaUNBQWlDLHdCQUF3QjtBQUN6RCwyQ0FBMkMsVUFBVTtBQUNyRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsK0VBQStFLHlDQUF5QztBQUN4SDtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE9BQU8sRUFBRSxZQUFZLEdBQUcsWUFBWTtBQUMzRjtBQUNBLHVDQUF1QyxVQUFVO0FBQ2pEO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsUUFBUTtBQUNsSCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLFdBQVcsTUFBTTtBQUNsSDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVc7QUFDaEUsMkdBQTJHLFFBQVE7QUFDbkgseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsK0VBQStFLHdCQUF3QjtBQUN2RztBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBLDBEQUEwRCxPQUFPLEVBQUUsWUFBWSxHQUFHLFlBQVk7QUFDOUY7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRCxxQkFBcUI7QUFDckIsMERBQTBELGFBQWEsbURBQW1EO0FBQzFIO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSwrRUFBK0Usd0JBQXdCO0FBQ3ZHO0FBQ0Esb0RBQW9ELGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0EsMERBQTBELE9BQU8sRUFBRSxZQUFZLEdBQUcsWUFBWTtBQUM5RjtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVtcGxhdGUtMi8uL25vZGVfbW9kdWxlcy9AZmFsLWFpL2NsaWVudC9zcmMvcXVldWUuanM/NjRiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVRdWV1ZUNsaWVudCA9IHZvaWQgMDtcbmNvbnN0IHJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuL3JlcXVlc3RcIik7XG5jb25zdCByZXNwb25zZV8xID0gcmVxdWlyZShcIi4vcmVzcG9uc2VcIik7XG5jb25zdCBzdHJlYW1pbmdfMSA9IHJlcXVpcmUoXCIuL3N0cmVhbWluZ1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IERFRkFVTFRfUE9MTF9JTlRFUlZBTCA9IDUwMDtcbmNvbnN0IGNyZWF0ZVF1ZXVlQ2xpZW50ID0gKHsgY29uZmlnLCBzdG9yYWdlLCB9KSA9PiB7XG4gICAgY29uc3QgcmVmID0ge1xuICAgICAgICBzdWJtaXQoZW5kcG9pbnRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHdlYmhvb2tVcmwsIHByaW9yaXR5IH0gPSBvcHRpb25zLCBydW5PcHRpb25zID0gX19yZXN0KG9wdGlvbnMsIFtcIndlYmhvb2tVcmxcIiwgXCJwcmlvcml0eVwiXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBvcHRpb25zLmlucHV0XG4gICAgICAgICAgICAgICAgICAgID8geWllbGQgc3RvcmFnZS50cmFuc2Zvcm1JbnB1dChvcHRpb25zLmlucHV0KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHJlcXVlc3RfMS5kaXNwYXRjaFJlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VXJsOiAoMCwgcmVxdWVzdF8xLmJ1aWxkVXJsKShlbmRwb2ludElkLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJ1bk9wdGlvbnMpLCB7IHN1YmRvbWFpbjogXCJxdWV1ZVwiLCBxdWVyeTogd2ViaG9va1VybCA/IHsgZmFsX3dlYmhvb2s6IHdlYmhvb2tVcmwgfSA6IHVuZGVmaW5lZCB9KSksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwieC1mYWwtcXVldWUtcHJpb3JpdHlcIjogcHJpb3JpdHkgIT09IG51bGwgJiYgcHJpb3JpdHkgIT09IHZvaWQgMCA/IHByaW9yaXR5IDogXCJub3JtYWxcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzdGF0dXMoZW5kcG9pbnRJZF8xLCBfYSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24qIChlbmRwb2ludElkLCB7IHJlcXVlc3RJZCwgbG9ncyA9IGZhbHNlLCBhYm9ydFNpZ25hbCB9KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwSWQgPSAoMCwgdXRpbHNfMS5wYXJzZUVuZHBvaW50SWQpKGVuZHBvaW50SWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGFwcElkLm5hbWVzcGFjZSA/IGAke2FwcElkLm5hbWVzcGFjZX0vYCA6IFwiXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCByZXF1ZXN0XzEuZGlzcGF0Y2hSZXF1ZXN0KSh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRcIixcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VXJsOiAoMCwgcmVxdWVzdF8xLmJ1aWxkVXJsKShgJHtwcmVmaXh9JHthcHBJZC5vd25lcn0vJHthcHBJZC5hbGlhc31gLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJkb21haW46IFwicXVldWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7IGxvZ3M6IGxvZ3MgPyBcIjFcIiA6IFwiMFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL3JlcXVlc3RzLyR7cmVxdWVzdElkfS9zdGF0dXNgLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmVhbVN0YXR1cyhlbmRwb2ludElkXzEsIF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiogKGVuZHBvaW50SWQsIHsgcmVxdWVzdElkLCBsb2dzID0gZmFsc2UsIGNvbm5lY3Rpb25Nb2RlIH0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcHBJZCA9ICgwLCB1dGlsc18xLnBhcnNlRW5kcG9pbnRJZCkoZW5kcG9pbnRJZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYXBwSWQubmFtZXNwYWNlID8gYCR7YXBwSWQubmFtZXNwYWNlfS9gIDogXCJcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG9nczogbG9ncyA/IFwiMVwiIDogXCIwXCIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSAoMCwgcmVxdWVzdF8xLmJ1aWxkVXJsKShgJHtwcmVmaXh9JHthcHBJZC5vd25lcn0vJHthcHBJZC5hbGlhc31gLCB7XG4gICAgICAgICAgICAgICAgICAgIHN1YmRvbWFpbjogXCJxdWV1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL3JlcXVlc3RzLyR7cmVxdWVzdElkfS9zdGF0dXMvc3RyZWFtYCxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3RyZWFtaW5nXzEuRmFsU3RyZWFtKGVuZHBvaW50SWQsIGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRcIixcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk1vZGUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN1YnNjcmliZVRvU3RhdHVzKGVuZHBvaW50SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdElkID0gb3B0aW9ucy5yZXF1ZXN0SWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgICAgICAgICAgICBsZXQgdGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNhbmNlbEVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzIGFzIHRoZSBjbGllbnQgd2lsbCBmb2xsb3cgdGhyb3VnaCB3aXRoIHRoZSB0aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2YgdGhlIHNlcnZlciByZXNwb25zZS4gSW4gY2FzZSBjYW5jZWxhdGlvbiBmYWlscywgd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RpbGwgd2FudCB0byByZWplY3QgdGhlIHByb21pc2UgYW5kIGNvbnNpZGVyIHRoZSBjbGllbnQgY2FsbCBjYW5jZWxlZC5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1vZGUgPT09IFwic3RyZWFtaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0geWllbGQgcmVmLnN0cmVhbVN0YXR1cyhlbmRwb2ludElkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dzOiBvcHRpb25zLmxvZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uTW9kZTogXCJjb25uZWN0aW9uTW9kZVwiIGluIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuY29ubmVjdGlvbk1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZi5jYW5jZWwoZW5kcG9pbnRJZCwgeyByZXF1ZXN0SWQgfSkuY2F0Y2goaGFuZGxlQ2FuY2VsRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBlcnJvciBjYW5ub3QgYnViYmxlIHVwIHRvIHRoZSB1c2VyIHNpbmNlIGl0J3MgdGhyb3duIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBjbG9zdXJlIGluIHRoZSBnbG9iYWwgc2NvcGUgZHVlIHRvIHNldFRpbWVvdXQgYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlciB3aWxsIGdldCBhIHBsYXRmb3JtIGVycm9yIGluc3RlYWQuIFdlIHNob3VsZCBmaW5kIGEgd2F5IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSB0aGlzIGJlaGF2aW9yIGFsaWduZWQgd2l0aCBwb2xsaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2xpZW50IHRpbWVkIG91dCB3YWl0aW5nIGZvciB0aGUgcmVxdWVzdCB0byBjb21wbGV0ZSBhZnRlciAke3RpbWVvdXR9bXNgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uUXVldWVVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2N1bXVsYXRlIGxvZ3MgdG8gbWF0Y2ggcHJldmlvdXMgcG9sbGluZyBiZWhhdmlvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImxvZ3NcIiBpbiBkYXRhICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZGF0YS5sb2dzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmxvZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dzLnB1c2goLi4uZGF0YS5sb2dzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vblF1ZXVlVXBkYXRlKFwibG9nc1wiIGluIGRhdGEgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IGxvZ3MgfSkgOiBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvbmVTdGF0dXMgPSB5aWVsZCBzdGF0dXMuZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9uZVN0YXR1cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBwb2xsaW5nIHVudGlsIHN0YXR1cyBzdHJlYW1pbmcgaXMgc3RhYmxlIGFuZCBmYXN0ZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2xsaW5nVGltZW91dElkO1xuICAgICAgICAgICAgICAgICAgICAvLyB0eXBlIHJlc29sdXRpb24gaXNuJ3QgZ3JlYXQgaW4gdGhpcyBjYXNlLCBzbyBjaGVjayBmb3IgaXRzIHByZXNlbmNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBhbmQgdHlwZSBzbyB0aGUgdHlwZWNoZWNrZXIgYmVoYXZlcyBhcyBleHBlY3RlZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2xsSW50ZXJ2YWwgPSBcInBvbGxJbnRlcnZhbFwiIGluIG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucG9sbEludGVydmFsID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICgoX2EgPSBvcHRpb25zLnBvbGxJbnRlcnZhbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogREVGQVVMVF9QT0xMX0lOVEVSVkFMKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBERUZBVUxUX1BPTExfSU5URVJWQUw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFyU2NoZWR1bGVkVGFza3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9sbGluZ1RpbWVvdXRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChwb2xsaW5nVGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyU2NoZWR1bGVkVGFza3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYuY2FuY2VsKGVuZHBvaW50SWQsIHsgcmVxdWVzdElkIH0pLmNhdGNoKGhhbmRsZUNhbmNlbEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBDbGllbnQgdGltZWQgb3V0IHdhaXRpbmcgZm9yIHRoZSByZXF1ZXN0IHRvIGNvbXBsZXRlIGFmdGVyICR7dGltZW91dH1tc2ApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvbGwgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RTdGF0dXMgPSB5aWVsZCByZWYuc3RhdHVzKGVuZHBvaW50SWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dzOiAoX2EgPSBvcHRpb25zLmxvZ3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucy5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vblF1ZXVlVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25RdWV1ZVVwZGF0ZShyZXF1ZXN0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RTdGF0dXMuc3RhdHVzID09PSBcIkNPTVBMRVRFRFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyU2NoZWR1bGVkVGFza3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0U3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2xsaW5nVGltZW91dElkID0gc2V0VGltZW91dChwb2xsLCBwb2xsSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJTY2hlZHVsZWRUYXNrcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwb2xsKCkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZXN1bHQoZW5kcG9pbnRJZF8xLCBfYSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24qIChlbmRwb2ludElkLCB7IHJlcXVlc3RJZCwgYWJvcnRTaWduYWwgfSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwcElkID0gKDAsIHV0aWxzXzEucGFyc2VFbmRwb2ludElkKShlbmRwb2ludElkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBhcHBJZC5uYW1lc3BhY2UgPyBgJHthcHBJZC5uYW1lc3BhY2V9L2AgOiBcIlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgcmVxdWVzdF8xLmRpc3BhdGNoUmVxdWVzdCkoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZ2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFVybDogKDAsIHJlcXVlc3RfMS5idWlsZFVybCkoYCR7cHJlZml4fSR7YXBwSWQub3duZXJ9LyR7YXBwSWQuYWxpYXN9YCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViZG9tYWluOiBcInF1ZXVlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL3JlcXVlc3RzLyR7cmVxdWVzdElkfWAsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwgeyByZXNwb25zZUhhbmRsZXI6IHJlc3BvbnNlXzEucmVzdWx0UmVzcG9uc2VIYW5kbGVyIH0pLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbChlbmRwb2ludElkXzEsIF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiogKGVuZHBvaW50SWQsIHsgcmVxdWVzdElkLCBhYm9ydFNpZ25hbCB9KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXBwSWQgPSAoMCwgdXRpbHNfMS5wYXJzZUVuZHBvaW50SWQpKGVuZHBvaW50SWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGFwcElkLm5hbWVzcGFjZSA/IGAke2FwcElkLm5hbWVzcGFjZX0vYCA6IFwiXCI7XG4gICAgICAgICAgICAgICAgeWllbGQgKDAsIHJlcXVlc3RfMS5kaXNwYXRjaFJlcXVlc3QpKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcInB1dFwiLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRVcmw6ICgwLCByZXF1ZXN0XzEuYnVpbGRVcmwpKGAke3ByZWZpeH0ke2FwcElkLm93bmVyfS8ke2FwcElkLmFsaWFzfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmRvbWFpbjogXCJxdWV1ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9yZXF1ZXN0cy8ke3JlcXVlc3RJZH0vY2FuY2VsYCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHJlZjtcbn07XG5leHBvcnRzLmNyZWF0ZVF1ZXVlQ2xpZW50ID0gY3JlYXRlUXVldWVDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWV1ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/queue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/realtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/realtime.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createRealtimeClient = createRealtimeClient;\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst msgpack_1 = __webpack_require__(/*! @msgpack/msgpack */ \"(rsc)/./node_modules/@msgpack/msgpack/dist.esm/index.mjs\");\nconst robot3_1 = __webpack_require__(/*! robot3 */ \"(rsc)/./node_modules/robot3/dist/machine.js\");\nconst auth_1 = __webpack_require__(/*! ./auth */ \"(rsc)/./node_modules/@fal-ai/client/src/auth.js\");\nconst response_1 = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/@fal-ai/client/src/response.js\");\nconst runtime_1 = __webpack_require__(/*! ./runtime */ \"(rsc)/./node_modules/@fal-ai/client/src/runtime.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@fal-ai/client/src/utils.js\");\nconst initialState = () => ({\n    enqueuedMessage: undefined,\n});\nfunction hasToken(context) {\n    return context.token !== undefined;\n}\nfunction noToken(context) {\n    return !hasToken(context);\n}\nfunction enqueueMessage(context, event) {\n    return Object.assign(Object.assign({}, context), { enqueuedMessage: event.message });\n}\nfunction closeConnection(context) {\n    if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {\n        context.websocket.close();\n    }\n    return Object.assign(Object.assign({}, context), { websocket: undefined });\n}\nfunction sendMessage(context, event) {\n    if (context.websocket && context.websocket.readyState === WebSocket.OPEN) {\n        if (event.message instanceof Uint8Array) {\n            context.websocket.send(event.message);\n        }\n        else {\n            context.websocket.send((0, msgpack_1.encode)(event.message));\n        }\n        return Object.assign(Object.assign({}, context), { enqueuedMessage: undefined });\n    }\n    return Object.assign(Object.assign({}, context), { enqueuedMessage: event.message });\n}\nfunction expireToken(context) {\n    return Object.assign(Object.assign({}, context), { token: undefined });\n}\nfunction setToken(context, event) {\n    return Object.assign(Object.assign({}, context), { token: event.token });\n}\nfunction connectionEstablished(context, event) {\n    return Object.assign(Object.assign({}, context), { websocket: event.websocket });\n}\n// State machine\nconst connectionStateMachine = (0, robot3_1.createMachine)(\"idle\", {\n    idle: (0, robot3_1.state)((0, robot3_1.transition)(\"send\", \"connecting\", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)(\"expireToken\", \"idle\", (0, robot3_1.reduce)(expireToken)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n    connecting: (0, robot3_1.state)((0, robot3_1.transition)(\"connecting\", \"connecting\"), (0, robot3_1.transition)(\"connected\", \"active\", (0, robot3_1.reduce)(connectionEstablished)), (0, robot3_1.transition)(\"connectionClosed\", \"idle\", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)(\"send\", \"connecting\", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.immediate)(\"authRequired\", (0, robot3_1.guard)(noToken))),\n    authRequired: (0, robot3_1.state)((0, robot3_1.transition)(\"initiateAuth\", \"authInProgress\"), (0, robot3_1.transition)(\"send\", \"authRequired\", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n    authInProgress: (0, robot3_1.state)((0, robot3_1.transition)(\"authenticated\", \"connecting\", (0, robot3_1.reduce)(setToken)), (0, robot3_1.transition)(\"unauthorized\", \"idle\", (0, robot3_1.reduce)(expireToken), (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)(\"send\", \"authInProgress\", (0, robot3_1.reduce)(enqueueMessage)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n    active: (0, robot3_1.state)((0, robot3_1.transition)(\"send\", \"active\", (0, robot3_1.reduce)(sendMessage)), (0, robot3_1.transition)(\"unauthorized\", \"idle\", (0, robot3_1.reduce)(expireToken)), (0, robot3_1.transition)(\"connectionClosed\", \"idle\", (0, robot3_1.reduce)(closeConnection)), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n    failed: (0, robot3_1.state)((0, robot3_1.transition)(\"send\", \"failed\"), (0, robot3_1.transition)(\"close\", \"idle\", (0, robot3_1.reduce)(closeConnection))),\n}, initialState);\nfunction buildRealtimeUrl(app, { token, maxBuffering }) {\n    if (maxBuffering !== undefined && (maxBuffering < 1 || maxBuffering > 60)) {\n        throw new Error(\"The `maxBuffering` must be between 1 and 60 (inclusive)\");\n    }\n    const queryParams = new URLSearchParams({\n        fal_jwt_token: token,\n    });\n    if (maxBuffering !== undefined) {\n        queryParams.set(\"max_buffering\", maxBuffering.toFixed(0));\n    }\n    const appId = (0, utils_1.ensureEndpointIdFormat)(app);\n    return `wss://fal.run/${appId}/realtime?${queryParams.toString()}`;\n}\nconst DEFAULT_THROTTLE_INTERVAL = 128;\nfunction isUnauthorizedError(message) {\n    // TODO we need better protocol definition with error codes\n    return message[\"status\"] === \"error\" && message[\"error\"] === \"Unauthorized\";\n}\n/**\n * See https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1\n */\nconst WebSocketErrorCodes = {\n    NORMAL_CLOSURE: 1000,\n    GOING_AWAY: 1001,\n};\nconst connectionCache = new Map();\nconst connectionCallbacks = new Map();\nfunction reuseInterpreter(key, throttleInterval, onChange) {\n    if (!connectionCache.has(key)) {\n        const machine = (0, robot3_1.interpret)(connectionStateMachine, onChange);\n        connectionCache.set(key, Object.assign(Object.assign({}, machine), { throttledSend: throttleInterval > 0\n                ? (0, utils_1.throttle)(machine.send, throttleInterval, true)\n                : machine.send }));\n    }\n    return connectionCache.get(key);\n}\nconst noop = () => {\n    /* No-op */\n};\n/**\n * A no-op connection that does not send any message.\n * Useful on the frameworks that reuse code for both ssr and csr (e.g. Next)\n * so the call when doing ssr has no side-effects.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst NoOpConnection = {\n    send: noop,\n    close: noop,\n};\nfunction isSuccessfulResult(data) {\n    return (data.status !== \"error\" &&\n        data.type !== \"x-fal-message\" &&\n        !isFalErrorResult(data));\n}\nfunction isFalErrorResult(data) {\n    return data.type === \"x-fal-error\";\n}\nfunction createRealtimeClient({ config, }) {\n    return {\n        connect(app, handler) {\n            const { \n            // if running on React in the server, set clientOnly to true by default\n            clientOnly = (0, utils_1.isReact)() && !(0, runtime_1.isBrowser)(), connectionKey = crypto.randomUUID(), maxBuffering, throttleInterval = DEFAULT_THROTTLE_INTERVAL, } = handler;\n            if (clientOnly && !(0, runtime_1.isBrowser)()) {\n                return NoOpConnection;\n            }\n            let previousState;\n            // Although the state machine is cached so we don't open multiple connections,\n            // we still need to update the callbacks so we can call the correct references\n            // when the state machine is reused. This is needed because the callbacks\n            // are passed as part of the handler object, which can be different across\n            // different calls to `connect`.\n            connectionCallbacks.set(connectionKey, {\n                onError: handler.onError,\n                onResult: handler.onResult,\n            });\n            const getCallbacks = () => connectionCallbacks.get(connectionKey);\n            const stateMachine = reuseInterpreter(connectionKey, throttleInterval, ({ context, machine, send }) => {\n                const { enqueuedMessage, token } = context;\n                if (machine.current === \"active\" && enqueuedMessage) {\n                    send({ type: \"send\", message: enqueuedMessage });\n                }\n                if (machine.current === \"authRequired\" &&\n                    token === undefined &&\n                    previousState !== machine.current) {\n                    send({ type: \"initiateAuth\" });\n                    (0, auth_1.getTemporaryAuthToken)(app, config)\n                        .then((token) => {\n                        send({ type: \"authenticated\", token });\n                        const tokenExpirationTimeout = Math.round(auth_1.TOKEN_EXPIRATION_SECONDS * 0.9 * 1000);\n                        setTimeout(() => {\n                            send({ type: \"expireToken\" });\n                        }, tokenExpirationTimeout);\n                    })\n                        .catch((error) => {\n                        send({ type: \"unauthorized\", error });\n                    });\n                }\n                if (machine.current === \"connecting\" &&\n                    previousState !== machine.current &&\n                    token !== undefined) {\n                    const ws = new WebSocket(buildRealtimeUrl(app, { token, maxBuffering }));\n                    ws.onopen = () => {\n                        send({ type: \"connected\", websocket: ws });\n                    };\n                    ws.onclose = (event) => {\n                        if (event.code !== WebSocketErrorCodes.NORMAL_CLOSURE) {\n                            const { onError = noop } = getCallbacks();\n                            onError(new response_1.ApiError({\n                                message: `Error closing the connection: ${event.reason}`,\n                                status: event.code,\n                            }));\n                        }\n                        send({ type: \"connectionClosed\", code: event.code });\n                    };\n                    ws.onerror = (event) => {\n                        // TODO specify error protocol for identified errors\n                        const { onError = noop } = getCallbacks();\n                        onError(new response_1.ApiError({ message: \"Unknown error\", status: 500 }));\n                    };\n                    ws.onmessage = (event) => {\n                        const { onResult } = getCallbacks();\n                        // Handle binary messages as msgpack messages\n                        if (event.data instanceof ArrayBuffer) {\n                            const result = (0, msgpack_1.decode)(new Uint8Array(event.data));\n                            onResult(result);\n                            return;\n                        }\n                        if (event.data instanceof Uint8Array) {\n                            const result = (0, msgpack_1.decode)(event.data);\n                            onResult(result);\n                            return;\n                        }\n                        if (event.data instanceof Blob) {\n                            event.data.arrayBuffer().then((buffer) => {\n                                const result = (0, msgpack_1.decode)(new Uint8Array(buffer));\n                                onResult(result);\n                            });\n                            return;\n                        }\n                        // Otherwise handle strings as plain JSON messages\n                        const data = JSON.parse(event.data);\n                        // Drop messages that are not related to the actual result.\n                        // In the future, we might want to handle other types of messages.\n                        // TODO: specify the fal ws protocol format\n                        if (isUnauthorizedError(data)) {\n                            send({\n                                type: \"unauthorized\",\n                                error: new Error(\"Unauthorized\"),\n                            });\n                            return;\n                        }\n                        if (isSuccessfulResult(data)) {\n                            onResult(data);\n                            return;\n                        }\n                        if (isFalErrorResult(data)) {\n                            if (data.error === \"TIMEOUT\") {\n                                // Timeout error messages just indicate that the connection hasn't\n                                // received an incoming message for a while. We don't need to\n                                // handle them as errors.\n                                return;\n                            }\n                            const { onError = noop } = getCallbacks();\n                            onError(new response_1.ApiError({\n                                message: `${data.error}: ${data.reason}`,\n                                // TODO better error status code\n                                status: 400,\n                                body: data,\n                            }));\n                            return;\n                        }\n                    };\n                }\n                previousState = machine.current;\n            });\n            const send = (input) => {\n                // Use throttled send to avoid sending too many messages\n                stateMachine.throttledSend({\n                    type: \"send\",\n                    message: input,\n                });\n            };\n            const close = () => {\n                stateMachine.send({ type: \"close\" });\n            };\n            return {\n                send,\n                close,\n            };\n        },\n    };\n}\n//# sourceMappingURL=realtime.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3JlYWx0aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QjtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGtGQUFrQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQywyREFBUTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsK0RBQVE7QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMsdUVBQVk7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMscUVBQVc7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQVM7QUFDakM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxjQUFjLGdDQUFnQztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGNBQWMsc0JBQXNCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjLDRCQUE0QjtBQUN2RjtBQUNBLHlDQUF5QyxjQUFjLGdDQUFnQztBQUN2RjtBQUNBO0FBQ0EseUNBQXlDLGNBQWMsa0JBQWtCO0FBQ3pFO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYyxvQkFBb0I7QUFDM0U7QUFDQTtBQUNBLHlDQUF5QyxjQUFjLDRCQUE0QjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUNBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU0sWUFBWSx1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGNBQWM7QUFDN0U7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtTEFBbUw7QUFDbkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esc0ZBQXNGLHdCQUF3QjtBQUM5Ryx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0EsMkJBQTJCLHdDQUF3QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBLCtCQUErQiw4QkFBOEI7QUFDN0Q7QUFDQTtBQUNBLG1DQUFtQyxxQkFBcUI7QUFDeEQseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBLCtCQUErQiw2QkFBNkI7QUFDNUQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHFCQUFxQjtBQUMxRjtBQUNBLCtCQUErQixrQ0FBa0M7QUFDakU7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsK0JBQStCLDRDQUE0QztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pELDBEQUEwRCx1Q0FBdUM7QUFDakc7QUFDQTtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBLDRDQUE0QyxXQUFXLElBQUksWUFBWTtBQUN2RTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxvQ0FBb0MsZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbXBsYXRlLTIvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3JlYWx0aW1lLmpzP2U4OWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVJlYWx0aW1lQ2xpZW50ID0gY3JlYXRlUmVhbHRpbWVDbGllbnQ7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCBtc2dwYWNrXzEgPSByZXF1aXJlKFwiQG1zZ3BhY2svbXNncGFja1wiKTtcbmNvbnN0IHJvYm90M18xID0gcmVxdWlyZShcInJvYm90M1wiKTtcbmNvbnN0IGF1dGhfMSA9IHJlcXVpcmUoXCIuL2F1dGhcIik7XG5jb25zdCByZXNwb25zZV8xID0gcmVxdWlyZShcIi4vcmVzcG9uc2VcIik7XG5jb25zdCBydW50aW1lXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgaW5pdGlhbFN0YXRlID0gKCkgPT4gKHtcbiAgICBlbnF1ZXVlZE1lc3NhZ2U6IHVuZGVmaW5lZCxcbn0pO1xuZnVuY3Rpb24gaGFzVG9rZW4oY29udGV4dCkge1xuICAgIHJldHVybiBjb250ZXh0LnRva2VuICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBub1Rva2VuKGNvbnRleHQpIHtcbiAgICByZXR1cm4gIWhhc1Rva2VuKGNvbnRleHQpO1xufVxuZnVuY3Rpb24gZW5xdWV1ZU1lc3NhZ2UoY29udGV4dCwgZXZlbnQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0KSwgeyBlbnF1ZXVlZE1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UgfSk7XG59XG5mdW5jdGlvbiBjbG9zZUNvbm5lY3Rpb24oY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LndlYnNvY2tldCAmJiBjb250ZXh0LndlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICBjb250ZXh0LndlYnNvY2tldC5jbG9zZSgpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0KSwgeyB3ZWJzb2NrZXQ6IHVuZGVmaW5lZCB9KTtcbn1cbmZ1bmN0aW9uIHNlbmRNZXNzYWdlKGNvbnRleHQsIGV2ZW50KSB7XG4gICAgaWYgKGNvbnRleHQud2Vic29ja2V0ICYmIGNvbnRleHQud2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICAgIGlmIChldmVudC5tZXNzYWdlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgY29udGV4dC53ZWJzb2NrZXQuc2VuZChldmVudC5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQud2Vic29ja2V0LnNlbmQoKDAsIG1zZ3BhY2tfMS5lbmNvZGUpKGV2ZW50Lm1lc3NhZ2UpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0KSwgeyBlbnF1ZXVlZE1lc3NhZ2U6IHVuZGVmaW5lZCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dCksIHsgZW5xdWV1ZWRNZXNzYWdlOiBldmVudC5tZXNzYWdlIH0pO1xufVxuZnVuY3Rpb24gZXhwaXJlVG9rZW4oY29udGV4dCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQpLCB7IHRva2VuOiB1bmRlZmluZWQgfSk7XG59XG5mdW5jdGlvbiBzZXRUb2tlbihjb250ZXh0LCBldmVudCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQpLCB7IHRva2VuOiBldmVudC50b2tlbiB9KTtcbn1cbmZ1bmN0aW9uIGNvbm5lY3Rpb25Fc3RhYmxpc2hlZChjb250ZXh0LCBldmVudCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQpLCB7IHdlYnNvY2tldDogZXZlbnQud2Vic29ja2V0IH0pO1xufVxuLy8gU3RhdGUgbWFjaGluZVxuY29uc3QgY29ubmVjdGlvblN0YXRlTWFjaGluZSA9ICgwLCByb2JvdDNfMS5jcmVhdGVNYWNoaW5lKShcImlkbGVcIiwge1xuICAgIGlkbGU6ICgwLCByb2JvdDNfMS5zdGF0ZSkoKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwic2VuZFwiLCBcImNvbm5lY3RpbmdcIiwgKDAsIHJvYm90M18xLnJlZHVjZSkoZW5xdWV1ZU1lc3NhZ2UpKSwgKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwiZXhwaXJlVG9rZW5cIiwgXCJpZGxlXCIsICgwLCByb2JvdDNfMS5yZWR1Y2UpKGV4cGlyZVRva2VuKSksICgwLCByb2JvdDNfMS50cmFuc2l0aW9uKShcImNsb3NlXCIsIFwiaWRsZVwiLCAoMCwgcm9ib3QzXzEucmVkdWNlKShjbG9zZUNvbm5lY3Rpb24pKSksXG4gICAgY29ubmVjdGluZzogKDAsIHJvYm90M18xLnN0YXRlKSgoMCwgcm9ib3QzXzEudHJhbnNpdGlvbikoXCJjb25uZWN0aW5nXCIsIFwiY29ubmVjdGluZ1wiKSwgKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwiY29ubmVjdGVkXCIsIFwiYWN0aXZlXCIsICgwLCByb2JvdDNfMS5yZWR1Y2UpKGNvbm5lY3Rpb25Fc3RhYmxpc2hlZCkpLCAoMCwgcm9ib3QzXzEudHJhbnNpdGlvbikoXCJjb25uZWN0aW9uQ2xvc2VkXCIsIFwiaWRsZVwiLCAoMCwgcm9ib3QzXzEucmVkdWNlKShjbG9zZUNvbm5lY3Rpb24pKSwgKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwic2VuZFwiLCBcImNvbm5lY3RpbmdcIiwgKDAsIHJvYm90M18xLnJlZHVjZSkoZW5xdWV1ZU1lc3NhZ2UpKSwgKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwiY2xvc2VcIiwgXCJpZGxlXCIsICgwLCByb2JvdDNfMS5yZWR1Y2UpKGNsb3NlQ29ubmVjdGlvbikpLCAoMCwgcm9ib3QzXzEuaW1tZWRpYXRlKShcImF1dGhSZXF1aXJlZFwiLCAoMCwgcm9ib3QzXzEuZ3VhcmQpKG5vVG9rZW4pKSksXG4gICAgYXV0aFJlcXVpcmVkOiAoMCwgcm9ib3QzXzEuc3RhdGUpKCgwLCByb2JvdDNfMS50cmFuc2l0aW9uKShcImluaXRpYXRlQXV0aFwiLCBcImF1dGhJblByb2dyZXNzXCIpLCAoMCwgcm9ib3QzXzEudHJhbnNpdGlvbikoXCJzZW5kXCIsIFwiYXV0aFJlcXVpcmVkXCIsICgwLCByb2JvdDNfMS5yZWR1Y2UpKGVucXVldWVNZXNzYWdlKSksICgwLCByb2JvdDNfMS50cmFuc2l0aW9uKShcImNsb3NlXCIsIFwiaWRsZVwiLCAoMCwgcm9ib3QzXzEucmVkdWNlKShjbG9zZUNvbm5lY3Rpb24pKSksXG4gICAgYXV0aEluUHJvZ3Jlc3M6ICgwLCByb2JvdDNfMS5zdGF0ZSkoKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwiYXV0aGVudGljYXRlZFwiLCBcImNvbm5lY3RpbmdcIiwgKDAsIHJvYm90M18xLnJlZHVjZSkoc2V0VG9rZW4pKSwgKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwidW5hdXRob3JpemVkXCIsIFwiaWRsZVwiLCAoMCwgcm9ib3QzXzEucmVkdWNlKShleHBpcmVUb2tlbiksICgwLCByb2JvdDNfMS5yZWR1Y2UpKGNsb3NlQ29ubmVjdGlvbikpLCAoMCwgcm9ib3QzXzEudHJhbnNpdGlvbikoXCJzZW5kXCIsIFwiYXV0aEluUHJvZ3Jlc3NcIiwgKDAsIHJvYm90M18xLnJlZHVjZSkoZW5xdWV1ZU1lc3NhZ2UpKSwgKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwiY2xvc2VcIiwgXCJpZGxlXCIsICgwLCByb2JvdDNfMS5yZWR1Y2UpKGNsb3NlQ29ubmVjdGlvbikpKSxcbiAgICBhY3RpdmU6ICgwLCByb2JvdDNfMS5zdGF0ZSkoKDAsIHJvYm90M18xLnRyYW5zaXRpb24pKFwic2VuZFwiLCBcImFjdGl2ZVwiLCAoMCwgcm9ib3QzXzEucmVkdWNlKShzZW5kTWVzc2FnZSkpLCAoMCwgcm9ib3QzXzEudHJhbnNpdGlvbikoXCJ1bmF1dGhvcml6ZWRcIiwgXCJpZGxlXCIsICgwLCByb2JvdDNfMS5yZWR1Y2UpKGV4cGlyZVRva2VuKSksICgwLCByb2JvdDNfMS50cmFuc2l0aW9uKShcImNvbm5lY3Rpb25DbG9zZWRcIiwgXCJpZGxlXCIsICgwLCByb2JvdDNfMS5yZWR1Y2UpKGNsb3NlQ29ubmVjdGlvbikpLCAoMCwgcm9ib3QzXzEudHJhbnNpdGlvbikoXCJjbG9zZVwiLCBcImlkbGVcIiwgKDAsIHJvYm90M18xLnJlZHVjZSkoY2xvc2VDb25uZWN0aW9uKSkpLFxuICAgIGZhaWxlZDogKDAsIHJvYm90M18xLnN0YXRlKSgoMCwgcm9ib3QzXzEudHJhbnNpdGlvbikoXCJzZW5kXCIsIFwiZmFpbGVkXCIpLCAoMCwgcm9ib3QzXzEudHJhbnNpdGlvbikoXCJjbG9zZVwiLCBcImlkbGVcIiwgKDAsIHJvYm90M18xLnJlZHVjZSkoY2xvc2VDb25uZWN0aW9uKSkpLFxufSwgaW5pdGlhbFN0YXRlKTtcbmZ1bmN0aW9uIGJ1aWxkUmVhbHRpbWVVcmwoYXBwLCB7IHRva2VuLCBtYXhCdWZmZXJpbmcgfSkge1xuICAgIGlmIChtYXhCdWZmZXJpbmcgIT09IHVuZGVmaW5lZCAmJiAobWF4QnVmZmVyaW5nIDwgMSB8fCBtYXhCdWZmZXJpbmcgPiA2MCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGBtYXhCdWZmZXJpbmdgIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA2MCAoaW5jbHVzaXZlKVwiKTtcbiAgICB9XG4gICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgZmFsX2p3dF90b2tlbjogdG9rZW4sXG4gICAgfSk7XG4gICAgaWYgKG1heEJ1ZmZlcmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHF1ZXJ5UGFyYW1zLnNldChcIm1heF9idWZmZXJpbmdcIiwgbWF4QnVmZmVyaW5nLnRvRml4ZWQoMCkpO1xuICAgIH1cbiAgICBjb25zdCBhcHBJZCA9ICgwLCB1dGlsc18xLmVuc3VyZUVuZHBvaW50SWRGb3JtYXQpKGFwcCk7XG4gICAgcmV0dXJuIGB3c3M6Ly9mYWwucnVuLyR7YXBwSWR9L3JlYWx0aW1lPyR7cXVlcnlQYXJhbXMudG9TdHJpbmcoKX1gO1xufVxuY29uc3QgREVGQVVMVF9USFJPVFRMRV9JTlRFUlZBTCA9IDEyODtcbmZ1bmN0aW9uIGlzVW5hdXRob3JpemVkRXJyb3IobWVzc2FnZSkge1xuICAgIC8vIFRPRE8gd2UgbmVlZCBiZXR0ZXIgcHJvdG9jb2wgZGVmaW5pdGlvbiB3aXRoIGVycm9yIGNvZGVzXG4gICAgcmV0dXJuIG1lc3NhZ2VbXCJzdGF0dXNcIl0gPT09IFwiZXJyb3JcIiAmJiBtZXNzYWdlW1wiZXJyb3JcIl0gPT09IFwiVW5hdXRob3JpemVkXCI7XG59XG4vKipcbiAqIFNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjQ1NS5odG1sI3NlY3Rpb24tNy40LjFcbiAqL1xuY29uc3QgV2ViU29ja2V0RXJyb3JDb2RlcyA9IHtcbiAgICBOT1JNQUxfQ0xPU1VSRTogMTAwMCxcbiAgICBHT0lOR19BV0FZOiAxMDAxLFxufTtcbmNvbnN0IGNvbm5lY3Rpb25DYWNoZSA9IG5ldyBNYXAoKTtcbmNvbnN0IGNvbm5lY3Rpb25DYWxsYmFja3MgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiByZXVzZUludGVycHJldGVyKGtleSwgdGhyb3R0bGVJbnRlcnZhbCwgb25DaGFuZ2UpIHtcbiAgICBpZiAoIWNvbm5lY3Rpb25DYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICBjb25zdCBtYWNoaW5lID0gKDAsIHJvYm90M18xLmludGVycHJldCkoY29ubmVjdGlvblN0YXRlTWFjaGluZSwgb25DaGFuZ2UpO1xuICAgICAgICBjb25uZWN0aW9uQ2FjaGUuc2V0KGtleSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtYWNoaW5lKSwgeyB0aHJvdHRsZWRTZW5kOiB0aHJvdHRsZUludGVydmFsID4gMFxuICAgICAgICAgICAgICAgID8gKDAsIHV0aWxzXzEudGhyb3R0bGUpKG1hY2hpbmUuc2VuZCwgdGhyb3R0bGVJbnRlcnZhbCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICA6IG1hY2hpbmUuc2VuZCB9KSk7XG4gICAgfVxuICAgIHJldHVybiBjb25uZWN0aW9uQ2FjaGUuZ2V0KGtleSk7XG59XG5jb25zdCBub29wID0gKCkgPT4ge1xuICAgIC8qIE5vLW9wICovXG59O1xuLyoqXG4gKiBBIG5vLW9wIGNvbm5lY3Rpb24gdGhhdCBkb2VzIG5vdCBzZW5kIGFueSBtZXNzYWdlLlxuICogVXNlZnVsIG9uIHRoZSBmcmFtZXdvcmtzIHRoYXQgcmV1c2UgY29kZSBmb3IgYm90aCBzc3IgYW5kIGNzciAoZS5nLiBOZXh0KVxuICogc28gdGhlIGNhbGwgd2hlbiBkb2luZyBzc3IgaGFzIG5vIHNpZGUtZWZmZWN0cy5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IE5vT3BDb25uZWN0aW9uID0ge1xuICAgIHNlbmQ6IG5vb3AsXG4gICAgY2xvc2U6IG5vb3AsXG59O1xuZnVuY3Rpb24gaXNTdWNjZXNzZnVsUmVzdWx0KGRhdGEpIHtcbiAgICByZXR1cm4gKGRhdGEuc3RhdHVzICE9PSBcImVycm9yXCIgJiZcbiAgICAgICAgZGF0YS50eXBlICE9PSBcIngtZmFsLW1lc3NhZ2VcIiAmJlxuICAgICAgICAhaXNGYWxFcnJvclJlc3VsdChkYXRhKSk7XG59XG5mdW5jdGlvbiBpc0ZhbEVycm9yUmVzdWx0KGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS50eXBlID09PSBcIngtZmFsLWVycm9yXCI7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWFsdGltZUNsaWVudCh7IGNvbmZpZywgfSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbm5lY3QoYXBwLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25zdCB7IFxuICAgICAgICAgICAgLy8gaWYgcnVubmluZyBvbiBSZWFjdCBpbiB0aGUgc2VydmVyLCBzZXQgY2xpZW50T25seSB0byB0cnVlIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIGNsaWVudE9ubHkgPSAoMCwgdXRpbHNfMS5pc1JlYWN0KSgpICYmICEoMCwgcnVudGltZV8xLmlzQnJvd3NlcikoKSwgY29ubmVjdGlvbktleSA9IGNyeXB0by5yYW5kb21VVUlEKCksIG1heEJ1ZmZlcmluZywgdGhyb3R0bGVJbnRlcnZhbCA9IERFRkFVTFRfVEhST1RUTEVfSU5URVJWQUwsIH0gPSBoYW5kbGVyO1xuICAgICAgICAgICAgaWYgKGNsaWVudE9ubHkgJiYgISgwLCBydW50aW1lXzEuaXNCcm93c2VyKSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5vT3BDb25uZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgICAvLyBBbHRob3VnaCB0aGUgc3RhdGUgbWFjaGluZSBpcyBjYWNoZWQgc28gd2UgZG9uJ3Qgb3BlbiBtdWx0aXBsZSBjb25uZWN0aW9ucyxcbiAgICAgICAgICAgIC8vIHdlIHN0aWxsIG5lZWQgdG8gdXBkYXRlIHRoZSBjYWxsYmFja3Mgc28gd2UgY2FuIGNhbGwgdGhlIGNvcnJlY3QgcmVmZXJlbmNlc1xuICAgICAgICAgICAgLy8gd2hlbiB0aGUgc3RhdGUgbWFjaGluZSBpcyByZXVzZWQuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGNhbGxiYWNrc1xuICAgICAgICAgICAgLy8gYXJlIHBhc3NlZCBhcyBwYXJ0IG9mIHRoZSBoYW5kbGVyIG9iamVjdCwgd2hpY2ggY2FuIGJlIGRpZmZlcmVudCBhY3Jvc3NcbiAgICAgICAgICAgIC8vIGRpZmZlcmVudCBjYWxscyB0byBgY29ubmVjdGAuXG4gICAgICAgICAgICBjb25uZWN0aW9uQ2FsbGJhY2tzLnNldChjb25uZWN0aW9uS2V5LCB7XG4gICAgICAgICAgICAgICAgb25FcnJvcjogaGFuZGxlci5vbkVycm9yLFxuICAgICAgICAgICAgICAgIG9uUmVzdWx0OiBoYW5kbGVyLm9uUmVzdWx0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBnZXRDYWxsYmFja3MgPSAoKSA9PiBjb25uZWN0aW9uQ2FsbGJhY2tzLmdldChjb25uZWN0aW9uS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlTWFjaGluZSA9IHJldXNlSW50ZXJwcmV0ZXIoY29ubmVjdGlvbktleSwgdGhyb3R0bGVJbnRlcnZhbCwgKHsgY29udGV4dCwgbWFjaGluZSwgc2VuZCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbnF1ZXVlZE1lc3NhZ2UsIHRva2VuIH0gPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIGlmIChtYWNoaW5lLmN1cnJlbnQgPT09IFwiYWN0aXZlXCIgJiYgZW5xdWV1ZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmQoeyB0eXBlOiBcInNlbmRcIiwgbWVzc2FnZTogZW5xdWV1ZWRNZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFjaGluZS5jdXJyZW50ID09PSBcImF1dGhSZXF1aXJlZFwiICYmXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNTdGF0ZSAhPT0gbWFjaGluZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmQoeyB0eXBlOiBcImluaXRpYXRlQXV0aFwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAoMCwgYXV0aF8xLmdldFRlbXBvcmFyeUF1dGhUb2tlbikoYXBwLCBjb25maWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigodG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQoeyB0eXBlOiBcImF1dGhlbnRpY2F0ZWRcIiwgdG9rZW4gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbkV4cGlyYXRpb25UaW1lb3V0ID0gTWF0aC5yb3VuZChhdXRoXzEuVE9LRU5fRVhQSVJBVElPTl9TRUNPTkRTICogMC45ICogMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kKHsgdHlwZTogXCJleHBpcmVUb2tlblwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdG9rZW5FeHBpcmF0aW9uVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kKHsgdHlwZTogXCJ1bmF1dGhvcml6ZWRcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFjaGluZS5jdXJyZW50ID09PSBcImNvbm5lY3RpbmdcIiAmJlxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1N0YXRlICE9PSBtYWNoaW5lLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQoYnVpbGRSZWFsdGltZVVybChhcHAsIHsgdG9rZW4sIG1heEJ1ZmZlcmluZyB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHdzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQoeyB0eXBlOiBcImNvbm5lY3RlZFwiLCB3ZWJzb2NrZXQ6IHdzIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB3cy5vbmNsb3NlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY29kZSAhPT0gV2ViU29ja2V0RXJyb3JDb2Rlcy5OT1JNQUxfQ0xPU1VSRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25FcnJvciA9IG5vb3AgfSA9IGdldENhbGxiYWNrcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IobmV3IHJlc3BvbnNlXzEuQXBpRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRXJyb3IgY2xvc2luZyB0aGUgY29ubmVjdGlvbjogJHtldmVudC5yZWFzb259YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBldmVudC5jb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQoeyB0eXBlOiBcImNvbm5lY3Rpb25DbG9zZWRcIiwgY29kZTogZXZlbnQuY29kZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgd3Mub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBzcGVjaWZ5IGVycm9yIHByb3RvY29sIGZvciBpZGVudGlmaWVkIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvbkVycm9yID0gbm9vcCB9ID0gZ2V0Q2FsbGJhY2tzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKG5ldyByZXNwb25zZV8xLkFwaUVycm9yKHsgbWVzc2FnZTogXCJVbmtub3duIGVycm9yXCIsIHN0YXR1czogNTAwIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgd3Mub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9uUmVzdWx0IH0gPSBnZXRDYWxsYmFja3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBiaW5hcnkgbWVzc2FnZXMgYXMgbXNncGFjayBtZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBtc2dwYWNrXzEuZGVjb2RlKShuZXcgVWludDhBcnJheShldmVudC5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSAoMCwgbXNncGFja18xLmRlY29kZSkoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLmFycmF5QnVmZmVyKCkudGhlbigoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBtc2dwYWNrXzEuZGVjb2RlKShuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgaGFuZGxlIHN0cmluZ3MgYXMgcGxhaW4gSlNPTiBtZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEcm9wIG1lc3NhZ2VzIHRoYXQgYXJlIG5vdCByZWxhdGVkIHRvIHRoZSBhY3R1YWwgcmVzdWx0LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIGZ1dHVyZSwgd2UgbWlnaHQgd2FudCB0byBoYW5kbGUgb3RoZXIgdHlwZXMgb2YgbWVzc2FnZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBzcGVjaWZ5IHRoZSBmYWwgd3MgcHJvdG9jb2wgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmF1dGhvcml6ZWRFcnJvcihkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInVuYXV0aG9yaXplZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFwiVW5hdXRob3JpemVkXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N1Y2Nlc3NmdWxSZXN1bHQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlc3VsdChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGYWxFcnJvclJlc3VsdChkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9yID09PSBcIlRJTUVPVVRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaW1lb3V0IGVycm9yIG1lc3NhZ2VzIGp1c3QgaW5kaWNhdGUgdGhhdCB0aGUgY29ubmVjdGlvbiBoYXNuJ3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjZWl2ZWQgYW4gaW5jb21pbmcgbWVzc2FnZSBmb3IgYSB3aGlsZS4gV2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdGhlbSBhcyBlcnJvcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvbkVycm9yID0gbm9vcCB9ID0gZ2V0Q2FsbGJhY2tzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihuZXcgcmVzcG9uc2VfMS5BcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke2RhdGEuZXJyb3J9OiAke2RhdGEucmVhc29ufWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gYmV0dGVyIGVycm9yIHN0YXR1cyBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogNDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzU3RhdGUgPSBtYWNoaW5lLmN1cnJlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNlbmQgPSAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhyb3R0bGVkIHNlbmQgdG8gYXZvaWQgc2VuZGluZyB0b28gbWFueSBtZXNzYWdlc1xuICAgICAgICAgICAgICAgIHN0YXRlTWFjaGluZS50aHJvdHRsZWRTZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGlucHV0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRlTWFjaGluZS5zZW5kKHsgdHlwZTogXCJjbG9zZVwiIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2VuZCxcbiAgICAgICAgICAgICAgICBjbG9zZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWx0aW1lLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/realtime.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/request.js":
/*!****************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/request.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dispatchRequest = dispatchRequest;\nexports.buildUrl = buildUrl;\nconst runtime_1 = __webpack_require__(/*! ./runtime */ \"(rsc)/./node_modules/@fal-ai/client/src/runtime.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@fal-ai/client/src/utils.js\");\nconst isCloudflareWorkers = typeof navigator !== \"undefined\" &&\n    (navigator === null || navigator === void 0 ? void 0 : navigator.userAgent) === \"Cloudflare-Workers\";\nfunction dispatchRequest(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a, _b, _c;\n        const { targetUrl, input, config, options = {} } = params;\n        const { credentials: credentialsValue, requestMiddleware, responseHandler, fetch, } = config;\n        const userAgent = (0, runtime_1.isBrowser)() ? {} : { \"User-Agent\": (0, runtime_1.getUserAgent)() };\n        const credentials = typeof credentialsValue === \"function\"\n            ? credentialsValue()\n            : credentialsValue;\n        const { method, url, headers } = yield requestMiddleware({\n            method: ((_b = (_a = params.method) !== null && _a !== void 0 ? _a : options.method) !== null && _b !== void 0 ? _b : \"post\").toUpperCase(),\n            url: targetUrl,\n            headers: params.headers,\n        });\n        const authHeader = credentials ? { Authorization: `Key ${credentials}` } : {};\n        const requestHeaders = Object.assign(Object.assign(Object.assign(Object.assign({}, authHeader), { Accept: \"application/json\", \"Content-Type\": \"application/json\" }), userAgent), (headers !== null && headers !== void 0 ? headers : {}));\n        const { responseHandler: customResponseHandler } = options, requestInit = __rest(options, [\"responseHandler\"]);\n        const response = yield fetch(url, Object.assign(Object.assign(Object.assign(Object.assign({}, requestInit), { method, headers: Object.assign(Object.assign({}, requestHeaders), ((_c = requestInit.headers) !== null && _c !== void 0 ? _c : {})) }), (!isCloudflareWorkers && { mode: \"cors\" })), { signal: options.signal, body: method.toLowerCase() !== \"get\" && input\n                ? JSON.stringify(input)\n                : undefined }));\n        const handleResponse = customResponseHandler !== null && customResponseHandler !== void 0 ? customResponseHandler : responseHandler;\n        return yield handleResponse(response);\n    });\n}\n/**\n * Builds the final url to run the function based on its `id` or alias and\n * a the options from `RunOptions<Input>`.\n *\n * @private\n * @param id the function id or alias\n * @param options the run options\n * @returns the final url to run the function\n */\nfunction buildUrl(id, options = {}) {\n    var _a, _b;\n    const method = ((_a = options.method) !== null && _a !== void 0 ? _a : \"post\").toLowerCase();\n    const path = ((_b = options.path) !== null && _b !== void 0 ? _b : \"\").replace(/^\\//, \"\").replace(/\\/{2,}/, \"/\");\n    const input = options.input;\n    const params = Object.assign(Object.assign({}, (options.query || {})), (method === \"get\" ? input : {}));\n    const queryParams = Object.keys(params).length > 0\n        ? `?${new URLSearchParams(params).toString()}`\n        : \"\";\n    // if a fal url is passed, just use it\n    if ((0, utils_1.isValidUrl)(id)) {\n        const url = id.endsWith(\"/\") ? id : `${id}/`;\n        return `${url}${path}${queryParams}`;\n    }\n    const appId = (0, utils_1.ensureEndpointIdFormat)(id);\n    const subdomain = options.subdomain ? `${options.subdomain}.` : \"\";\n    const url = `https://${subdomain}fal.run/${appId}/${path}`;\n    return `${url.replace(/\\/$/, \"\")}${queryParams}`;\n}\n//# sourceMappingURL=request.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3JlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQixrQkFBa0IsbUJBQU8sQ0FBQyxxRUFBVztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RCxnQkFBZ0IsNEVBQTRFO0FBQzVGLDBEQUEwRCxJQUFJO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJDQUEyQyxzQkFBc0IsWUFBWSxJQUFJO0FBQ2pGLHlGQUF5RixpQkFBaUIsZ0VBQWdFLHFFQUFxRTtBQUMvTyxnQkFBZ0IseUNBQXlDO0FBQ3pELG9HQUFvRyxrQkFBa0IsK0NBQStDLGtGQUFrRixJQUFJLDhCQUE4QixjQUFjLE1BQU07QUFDN1M7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsMEdBQTBHLEdBQUc7QUFDN0c7QUFDQSxpREFBaUQsc0JBQXNCLGtDQUFrQztBQUN6RztBQUNBLGNBQWMsdUNBQXVDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxHQUFHO0FBQ2xELGtCQUFrQixJQUFJLEVBQUUsS0FBSyxFQUFFLFlBQVk7QUFDM0M7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0QsMkJBQTJCLFVBQVUsVUFBVSxNQUFNLEdBQUcsS0FBSztBQUM3RCxjQUFjLHVCQUF1QixFQUFFLFlBQVk7QUFDbkQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbXBsYXRlLTIvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3JlcXVlc3QuanM/Y2Y4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kaXNwYXRjaFJlcXVlc3QgPSBkaXNwYXRjaFJlcXVlc3Q7XG5leHBvcnRzLmJ1aWxkVXJsID0gYnVpbGRVcmw7XG5jb25zdCBydW50aW1lXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgaXNDbG91ZGZsYXJlV29ya2VycyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAobmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLnVzZXJBZ2VudCkgPT09IFwiQ2xvdWRmbGFyZS1Xb3JrZXJzXCI7XG5mdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QocGFyYW1zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0VXJsLCBpbnB1dCwgY29uZmlnLCBvcHRpb25zID0ge30gfSA9IHBhcmFtcztcbiAgICAgICAgY29uc3QgeyBjcmVkZW50aWFsczogY3JlZGVudGlhbHNWYWx1ZSwgcmVxdWVzdE1pZGRsZXdhcmUsIHJlc3BvbnNlSGFuZGxlciwgZmV0Y2gsIH0gPSBjb25maWc7XG4gICAgICAgIGNvbnN0IHVzZXJBZ2VudCA9ICgwLCBydW50aW1lXzEuaXNCcm93c2VyKSgpID8ge30gOiB7IFwiVXNlci1BZ2VudFwiOiAoMCwgcnVudGltZV8xLmdldFVzZXJBZ2VudCkoKSB9O1xuICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IHR5cGVvZiBjcmVkZW50aWFsc1ZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gY3JlZGVudGlhbHNWYWx1ZSgpXG4gICAgICAgICAgICA6IGNyZWRlbnRpYWxzVmFsdWU7XG4gICAgICAgIGNvbnN0IHsgbWV0aG9kLCB1cmwsIGhlYWRlcnMgfSA9IHlpZWxkIHJlcXVlc3RNaWRkbGV3YXJlKHtcbiAgICAgICAgICAgIG1ldGhvZDogKChfYiA9IChfYSA9IHBhcmFtcy5tZXRob2QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wdGlvbnMubWV0aG9kKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcInBvc3RcIikudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgIHVybDogdGFyZ2V0VXJsLFxuICAgICAgICAgICAgaGVhZGVyczogcGFyYW1zLmhlYWRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhdXRoSGVhZGVyID0gY3JlZGVudGlhbHMgPyB7IEF1dGhvcml6YXRpb246IGBLZXkgJHtjcmVkZW50aWFsc31gIH0gOiB7fTtcbiAgICAgICAgY29uc3QgcmVxdWVzdEhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhdXRoSGVhZGVyKSwgeyBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9KSwgdXNlckFnZW50KSwgKGhlYWRlcnMgIT09IG51bGwgJiYgaGVhZGVycyAhPT0gdm9pZCAwID8gaGVhZGVycyA6IHt9KSk7XG4gICAgICAgIGNvbnN0IHsgcmVzcG9uc2VIYW5kbGVyOiBjdXN0b21SZXNwb25zZUhhbmRsZXIgfSA9IG9wdGlvbnMsIHJlcXVlc3RJbml0ID0gX19yZXN0KG9wdGlvbnMsIFtcInJlc3BvbnNlSGFuZGxlclwiXSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2godXJsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0SW5pdCksIHsgbWV0aG9kLCBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3RIZWFkZXJzKSwgKChfYyA9IHJlcXVlc3RJbml0LmhlYWRlcnMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9KSkgfSksICghaXNDbG91ZGZsYXJlV29ya2VycyAmJiB7IG1vZGU6IFwiY29yc1wiIH0pKSwgeyBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLCBib2R5OiBtZXRob2QudG9Mb3dlckNhc2UoKSAhPT0gXCJnZXRcIiAmJiBpbnB1dFxuICAgICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoaW5wdXQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQgfSkpO1xuICAgICAgICBjb25zdCBoYW5kbGVSZXNwb25zZSA9IGN1c3RvbVJlc3BvbnNlSGFuZGxlciAhPT0gbnVsbCAmJiBjdXN0b21SZXNwb25zZUhhbmRsZXIgIT09IHZvaWQgMCA/IGN1c3RvbVJlc3BvbnNlSGFuZGxlciA6IHJlc3BvbnNlSGFuZGxlcjtcbiAgICAgICAgcmV0dXJuIHlpZWxkIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQnVpbGRzIHRoZSBmaW5hbCB1cmwgdG8gcnVuIHRoZSBmdW5jdGlvbiBiYXNlZCBvbiBpdHMgYGlkYCBvciBhbGlhcyBhbmRcbiAqIGEgdGhlIG9wdGlvbnMgZnJvbSBgUnVuT3B0aW9uczxJbnB1dD5gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gaWQgdGhlIGZ1bmN0aW9uIGlkIG9yIGFsaWFzXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgcnVuIG9wdGlvbnNcbiAqIEByZXR1cm5zIHRoZSBmaW5hbCB1cmwgdG8gcnVuIHRoZSBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBidWlsZFVybChpZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBtZXRob2QgPSAoKF9hID0gb3B0aW9ucy5tZXRob2QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwicG9zdFwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHBhdGggPSAoKF9iID0gb3B0aW9ucy5wYXRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiKS5yZXBsYWNlKC9eXFwvLywgXCJcIikucmVwbGFjZSgvXFwvezIsfS8sIFwiL1wiKTtcbiAgICBjb25zdCBpbnB1dCA9IG9wdGlvbnMuaW5wdXQ7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAob3B0aW9ucy5xdWVyeSB8fCB7fSkpLCAobWV0aG9kID09PSBcImdldFwiID8gaW5wdXQgOiB7fSkpO1xuICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPiAwXG4gICAgICAgID8gYD8ke25ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKS50b1N0cmluZygpfWBcbiAgICAgICAgOiBcIlwiO1xuICAgIC8vIGlmIGEgZmFsIHVybCBpcyBwYXNzZWQsIGp1c3QgdXNlIGl0XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzVmFsaWRVcmwpKGlkKSkge1xuICAgICAgICBjb25zdCB1cmwgPSBpZC5lbmRzV2l0aChcIi9cIikgPyBpZCA6IGAke2lkfS9gO1xuICAgICAgICByZXR1cm4gYCR7dXJsfSR7cGF0aH0ke3F1ZXJ5UGFyYW1zfWA7XG4gICAgfVxuICAgIGNvbnN0IGFwcElkID0gKDAsIHV0aWxzXzEuZW5zdXJlRW5kcG9pbnRJZEZvcm1hdCkoaWQpO1xuICAgIGNvbnN0IHN1YmRvbWFpbiA9IG9wdGlvbnMuc3ViZG9tYWluID8gYCR7b3B0aW9ucy5zdWJkb21haW59LmAgOiBcIlwiO1xuICAgIGNvbnN0IHVybCA9IGBodHRwczovLyR7c3ViZG9tYWlufWZhbC5ydW4vJHthcHBJZH0vJHtwYXRofWA7XG4gICAgcmV0dXJuIGAke3VybC5yZXBsYWNlKC9cXC8kLywgXCJcIil9JHtxdWVyeVBhcmFtc31gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/response.js":
/*!*****************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/response.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ValidationError = exports.ApiError = void 0;\nexports.defaultResponseHandler = defaultResponseHandler;\nexports.resultResponseHandler = resultResponseHandler;\nconst REQUEST_ID_HEADER = \"x-fal-request-id\";\nclass ApiError extends Error {\n    constructor({ message, status, body }) {\n        super(message);\n        this.name = \"ApiError\";\n        this.status = status;\n        this.body = body;\n    }\n}\nexports.ApiError = ApiError;\nclass ValidationError extends ApiError {\n    constructor(args) {\n        super(args);\n        this.name = \"ValidationError\";\n    }\n    get fieldErrors() {\n        // NOTE: this is a hack to support both FastAPI/Pydantic errors\n        // and some custom 422 errors that might not be in the Pydantic format.\n        if (typeof this.body.detail === \"string\") {\n            return [\n                {\n                    loc: [\"body\"],\n                    msg: this.body.detail,\n                    type: \"value_error\",\n                },\n            ];\n        }\n        return this.body.detail || [];\n    }\n    getFieldErrors(field) {\n        return this.fieldErrors.filter((error) => error.loc[error.loc.length - 1] === field);\n    }\n}\nexports.ValidationError = ValidationError;\nfunction defaultResponseHandler(response) {\n    return __awaiter(this, void 0, void 0, function* () {\n        var _a;\n        const { status, statusText } = response;\n        const contentType = (_a = response.headers.get(\"Content-Type\")) !== null && _a !== void 0 ? _a : \"\";\n        if (!response.ok) {\n            if (contentType.includes(\"application/json\")) {\n                const body = yield response.json();\n                const ErrorType = status === 422 ? ValidationError : ApiError;\n                throw new ErrorType({\n                    message: body.message || statusText,\n                    status,\n                    body,\n                });\n            }\n            throw new ApiError({ message: `HTTP ${status}: ${statusText}`, status });\n        }\n        if (contentType.includes(\"application/json\")) {\n            return response.json();\n        }\n        if (contentType.includes(\"text/html\")) {\n            return response.text();\n        }\n        if (contentType.includes(\"application/octet-stream\")) {\n            return response.arrayBuffer();\n        }\n        // TODO convert to either number or bool automatically\n        return response.text();\n    });\n}\nfunction resultResponseHandler(response) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const data = yield defaultResponseHandler(response);\n        return {\n            data,\n            requestId: response.headers.get(REQUEST_ID_HEADER) || \"\",\n        };\n    });\n}\n//# sourceMappingURL=response.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3Jlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxnQkFBZ0I7QUFDMUMsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUNBQWlDLGlCQUFpQixPQUFPLElBQUksV0FBVyxXQUFXO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZW1wbGF0ZS0yLy4vbm9kZV9tb2R1bGVzL0BmYWwtYWkvY2xpZW50L3NyYy9yZXNwb25zZS5qcz9jZDhiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IGV4cG9ydHMuQXBpRXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLmRlZmF1bHRSZXNwb25zZUhhbmRsZXIgPSBkZWZhdWx0UmVzcG9uc2VIYW5kbGVyO1xuZXhwb3J0cy5yZXN1bHRSZXNwb25zZUhhbmRsZXIgPSByZXN1bHRSZXNwb25zZUhhbmRsZXI7XG5jb25zdCBSRVFVRVNUX0lEX0hFQURFUiA9IFwieC1mYWwtcmVxdWVzdC1pZFwiO1xuY2xhc3MgQXBpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtZXNzYWdlLCBzdGF0dXMsIGJvZHkgfSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBcGlFcnJvclwiO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB9XG59XG5leHBvcnRzLkFwaUVycm9yID0gQXBpRXJyb3I7XG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBBcGlFcnJvciB7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICBzdXBlcihhcmdzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJWYWxpZGF0aW9uRXJyb3JcIjtcbiAgICB9XG4gICAgZ2V0IGZpZWxkRXJyb3JzKCkge1xuICAgICAgICAvLyBOT1RFOiB0aGlzIGlzIGEgaGFjayB0byBzdXBwb3J0IGJvdGggRmFzdEFQSS9QeWRhbnRpYyBlcnJvcnNcbiAgICAgICAgLy8gYW5kIHNvbWUgY3VzdG9tIDQyMiBlcnJvcnMgdGhhdCBtaWdodCBub3QgYmUgaW4gdGhlIFB5ZGFudGljIGZvcm1hdC5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmJvZHkuZGV0YWlsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jOiBbXCJib2R5XCJdLFxuICAgICAgICAgICAgICAgICAgICBtc2c6IHRoaXMuYm9keS5kZXRhaWwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidmFsdWVfZXJyb3JcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ib2R5LmRldGFpbCB8fCBbXTtcbiAgICB9XG4gICAgZ2V0RmllbGRFcnJvcnMoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRFcnJvcnMuZmlsdGVyKChlcnJvcikgPT4gZXJyb3IubG9jW2Vycm9yLmxvYy5sZW5ndGggLSAxXSA9PT0gZmllbGQpO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gVmFsaWRhdGlvbkVycm9yO1xuZnVuY3Rpb24gZGVmYXVsdFJlc3BvbnNlSGFuZGxlcihyZXNwb25zZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIHN0YXR1c1RleHQgfSA9IHJlc3BvbnNlO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IChfYSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBFcnJvclR5cGUgPSBzdGF0dXMgPT09IDQyMiA/IFZhbGlkYXRpb25FcnJvciA6IEFwaUVycm9yO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvclR5cGUoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBib2R5Lm1lc3NhZ2UgfHwgc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEFwaUVycm9yKHsgbWVzc2FnZTogYEhUVFAgJHtzdGF0dXN9OiAke3N0YXR1c1RleHR9YCwgc3RhdHVzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwidGV4dC9odG1sXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBjb252ZXJ0IHRvIGVpdGhlciBudW1iZXIgb3IgYm9vbCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZXN1bHRSZXNwb25zZUhhbmRsZXIocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBkYXRhID0geWllbGQgZGVmYXVsdFJlc3BvbnNlSGFuZGxlcihyZXNwb25zZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmVxdWVzdElkOiByZXNwb25zZS5oZWFkZXJzLmdldChSRVFVRVNUX0lEX0hFQURFUikgfHwgXCJcIixcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc3BvbnNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/runtime.js":
/*!****************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/runtime.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/* eslint-disable @typescript-eslint/no-var-requires */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isBrowser = isBrowser;\nexports.getUserAgent = getUserAgent;\nfunction isBrowser() {\n    return (typeof window !== \"undefined\" && typeof window.document !== \"undefined\");\n}\nlet memoizedUserAgent = null;\nfunction getUserAgent() {\n    if (memoizedUserAgent !== null) {\n        return memoizedUserAgent;\n    }\n    const packageInfo = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/@fal-ai/client/package.json\");\n    memoizedUserAgent = `${packageInfo.name}/${packageInfo.version}`;\n    return memoizedUserAgent;\n}\n//# sourceMappingURL=runtime.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3J1bnRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyx5RUFBaUI7QUFDakQsMkJBQTJCLGlCQUFpQixHQUFHLG9CQUFvQjtBQUNuRTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZW1wbGF0ZS0yLy4vbm9kZV9tb2R1bGVzL0BmYWwtYWkvY2xpZW50L3NyYy9ydW50aW1lLmpzPzEwZjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQnJvd3NlciA9IGlzQnJvd3NlcjtcbmV4cG9ydHMuZ2V0VXNlckFnZW50ID0gZ2V0VXNlckFnZW50O1xuZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKTtcbn1cbmxldCBtZW1vaXplZFVzZXJBZ2VudCA9IG51bGw7XG5mdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gICAgaWYgKG1lbW9pemVkVXNlckFnZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtZW1vaXplZFVzZXJBZ2VudDtcbiAgICB9XG4gICAgY29uc3QgcGFja2FnZUluZm8gPSByZXF1aXJlKFwiLi4vcGFja2FnZS5qc29uXCIpO1xuICAgIG1lbW9pemVkVXNlckFnZW50ID0gYCR7cGFja2FnZUluZm8ubmFtZX0vJHtwYWNrYWdlSW5mby52ZXJzaW9ufWA7XG4gICAgcmV0dXJuIG1lbW9pemVkVXNlckFnZW50O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVudGltZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/runtime.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/storage.js":
/*!****************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/storage.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createStorageClient = createStorageClient;\nconst config_1 = __webpack_require__(/*! ./config */ \"(rsc)/./node_modules/@fal-ai/client/src/config.js\");\nconst request_1 = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/@fal-ai/client/src/request.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@fal-ai/client/src/utils.js\");\n/**\n * Get the file extension from the content type. This is used to generate\n * a file name if the file name is not provided.\n *\n * @param contentType the content type of the file.\n * @returns the file extension or `bin` if the content type is not recognized.\n */\nfunction getExtensionFromContentType(contentType) {\n    var _a;\n    const [_, fileType] = contentType.split(\"/\");\n    return (_a = fileType.split(/[-;]/)[0]) !== null && _a !== void 0 ? _a : \"bin\";\n}\n/**\n * Initiate the upload of a file to the server. This returns the URL to upload\n * the file to and the URL of the file once it is uploaded.\n */\nfunction initiateUpload(file, config, contentType) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const filename = file.name || `${Date.now()}.${getExtensionFromContentType(contentType)}`;\n        return yield (0, request_1.dispatchRequest)({\n            method: \"POST\",\n            // NOTE: We want to test V3 without making it the default at the API level\n            targetUrl: `${(0, config_1.getRestApiUrl)()}/storage/upload/initiate?storage_type=fal-cdn-v3`,\n            input: {\n                content_type: contentType,\n                file_name: filename,\n            },\n            config,\n        });\n    });\n}\n/**\n * Initiate the multipart upload of a file to the server. This returns the URL to upload\n * the file to and the URL of the file once it is uploaded.\n */\nfunction initiateMultipartUpload(file, config, contentType) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const filename = file.name || `${Date.now()}.${getExtensionFromContentType(contentType)}`;\n        return yield (0, request_1.dispatchRequest)({\n            method: \"POST\",\n            targetUrl: `${(0, config_1.getRestApiUrl)()}/storage/upload/initiate-multipart?storage_type=fal-cdn-v3`,\n            input: {\n                content_type: contentType,\n                file_name: filename,\n            },\n            config,\n        });\n    });\n}\nfunction partUploadRetries(uploadUrl_1, chunk_1, config_2) {\n    return __awaiter(this, arguments, void 0, function* (uploadUrl, chunk, config, tries = 3) {\n        if (tries === 0) {\n            throw new Error(\"Part upload failed, retries exhausted\");\n        }\n        const { fetch, responseHandler } = config;\n        try {\n            const response = yield fetch(uploadUrl, {\n                method: \"PUT\",\n                body: chunk,\n            });\n            return (yield responseHandler(response));\n        }\n        catch (error) {\n            return yield partUploadRetries(uploadUrl, chunk, config, tries - 1);\n        }\n    });\n}\nfunction multipartUpload(file, config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { fetch, responseHandler } = config;\n        const contentType = file.type || \"application/octet-stream\";\n        const { upload_url: uploadUrl, file_url: url } = yield initiateMultipartUpload(file, config, contentType);\n        // Break the file into 10MB chunks\n        const chunkSize = 10 * 1024 * 1024;\n        const chunks = Math.ceil(file.size / chunkSize);\n        const parsedUrl = new URL(uploadUrl);\n        const responses = [];\n        for (let i = 0; i < chunks; i++) {\n            const start = i * chunkSize;\n            const end = Math.min(start + chunkSize, file.size);\n            const chunk = file.slice(start, end);\n            const partNumber = i + 1;\n            // {uploadUrl}/{part_number}?uploadUrlParams=...\n            const partUploadUrl = `${parsedUrl.origin}${parsedUrl.pathname}/${partNumber}${parsedUrl.search}`;\n            responses.push(yield partUploadRetries(partUploadUrl, chunk, config));\n        }\n        // Complete the upload\n        const completeUrl = `${parsedUrl.origin}${parsedUrl.pathname}/complete${parsedUrl.search}`;\n        const response = yield fetch(completeUrl, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n                parts: responses.map((mpart) => ({\n                    partNumber: mpart.partNumber,\n                    etag: mpart.etag,\n                })),\n            }),\n        });\n        yield responseHandler(response);\n        return url;\n    });\n}\nfunction createStorageClient({ config, }) {\n    const ref = {\n        upload: (file) => __awaiter(this, void 0, void 0, function* () {\n            // Check for 90+ MB file size to do multipart upload\n            if (file.size > 90 * 1024 * 1024) {\n                return yield multipartUpload(file, config);\n            }\n            const contentType = file.type || \"application/octet-stream\";\n            const { fetch, responseHandler } = config;\n            const { upload_url: uploadUrl, file_url: url } = yield initiateUpload(file, config, contentType);\n            const response = yield fetch(uploadUrl, {\n                method: \"PUT\",\n                body: file,\n                headers: {\n                    \"Content-Type\": file.type || \"application/octet-stream\",\n                },\n            });\n            yield responseHandler(response);\n            return url;\n        }),\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        transformInput: (input) => __awaiter(this, void 0, void 0, function* () {\n            if (Array.isArray(input)) {\n                return Promise.all(input.map((item) => ref.transformInput(item)));\n            }\n            else if (input instanceof Blob) {\n                return yield ref.upload(input);\n            }\n            else if ((0, utils_1.isPlainObject)(input)) {\n                const inputObject = input;\n                const promises = Object.entries(inputObject).map((_a) => __awaiter(this, [_a], void 0, function* ([key, value]) {\n                    return [key, yield ref.transformInput(value)];\n                }));\n                const results = yield Promise.all(promises);\n                return Object.fromEntries(results);\n            }\n            // Return the input as is if it's neither an object nor a file/blob/data URI\n            return input;\n        }),\n    };\n    return ref;\n}\n//# sourceMappingURL=storage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3N0b3JhZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQixpQkFBaUIsbUJBQU8sQ0FBQyxtRUFBVTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxxRUFBVztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXLEdBQUcseUNBQXlDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXLEdBQUcseUNBQXlDO0FBQ2hHO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVLEVBQUUsWUFBWTtBQUN4QyxxQ0FBcUMsaUJBQWlCLEVBQUUsbUJBQW1CLEdBQUcsV0FBVyxFQUFFLGlCQUFpQjtBQUM1RztBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCLEVBQUUsbUJBQW1CLFdBQVcsaUJBQWlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZW1wbGF0ZS0yLy4vbm9kZV9tb2R1bGVzL0BmYWwtYWkvY2xpZW50L3NyYy9zdG9yYWdlLmpzPzA0YjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlU3RvcmFnZUNsaWVudCA9IGNyZWF0ZVN0b3JhZ2VDbGllbnQ7XG5jb25zdCBjb25maWdfMSA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcbmNvbnN0IHJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuL3JlcXVlc3RcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIEdldCB0aGUgZmlsZSBleHRlbnNpb24gZnJvbSB0aGUgY29udGVudCB0eXBlLiBUaGlzIGlzIHVzZWQgdG8gZ2VuZXJhdGVcbiAqIGEgZmlsZSBuYW1lIGlmIHRoZSBmaWxlIG5hbWUgaXMgbm90IHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSBjb250ZW50VHlwZSB0aGUgY29udGVudCB0eXBlIG9mIHRoZSBmaWxlLlxuICogQHJldHVybnMgdGhlIGZpbGUgZXh0ZW5zaW9uIG9yIGBiaW5gIGlmIHRoZSBjb250ZW50IHR5cGUgaXMgbm90IHJlY29nbml6ZWQuXG4gKi9cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbkZyb21Db250ZW50VHlwZShjb250ZW50VHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBbXywgZmlsZVR5cGVdID0gY29udGVudFR5cGUuc3BsaXQoXCIvXCIpO1xuICAgIHJldHVybiAoX2EgPSBmaWxlVHlwZS5zcGxpdCgvWy07XS8pWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcImJpblwiO1xufVxuLyoqXG4gKiBJbml0aWF0ZSB0aGUgdXBsb2FkIG9mIGEgZmlsZSB0byB0aGUgc2VydmVyLiBUaGlzIHJldHVybnMgdGhlIFVSTCB0byB1cGxvYWRcbiAqIHRoZSBmaWxlIHRvIGFuZCB0aGUgVVJMIG9mIHRoZSBmaWxlIG9uY2UgaXQgaXMgdXBsb2FkZWQuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYXRlVXBsb2FkKGZpbGUsIGNvbmZpZywgY29udGVudFR5cGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGZpbGUubmFtZSB8fCBgJHtEYXRlLm5vdygpfS4ke2dldEV4dGVuc2lvbkZyb21Db250ZW50VHlwZShjb250ZW50VHlwZSl9YDtcbiAgICAgICAgcmV0dXJuIHlpZWxkICgwLCByZXF1ZXN0XzEuZGlzcGF0Y2hSZXF1ZXN0KSh7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgLy8gTk9URTogV2Ugd2FudCB0byB0ZXN0IFYzIHdpdGhvdXQgbWFraW5nIGl0IHRoZSBkZWZhdWx0IGF0IHRoZSBBUEkgbGV2ZWxcbiAgICAgICAgICAgIHRhcmdldFVybDogYCR7KDAsIGNvbmZpZ18xLmdldFJlc3RBcGlVcmwpKCl9L3N0b3JhZ2UvdXBsb2FkL2luaXRpYXRlP3N0b3JhZ2VfdHlwZT1mYWwtY2RuLXYzYCxcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgICAgY29udGVudF90eXBlOiBjb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBmaWxlX25hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vKipcbiAqIEluaXRpYXRlIHRoZSBtdWx0aXBhcnQgdXBsb2FkIG9mIGEgZmlsZSB0byB0aGUgc2VydmVyLiBUaGlzIHJldHVybnMgdGhlIFVSTCB0byB1cGxvYWRcbiAqIHRoZSBmaWxlIHRvIGFuZCB0aGUgVVJMIG9mIHRoZSBmaWxlIG9uY2UgaXQgaXMgdXBsb2FkZWQuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYXRlTXVsdGlwYXJ0VXBsb2FkKGZpbGUsIGNvbmZpZywgY29udGVudFR5cGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGZpbGUubmFtZSB8fCBgJHtEYXRlLm5vdygpfS4ke2dldEV4dGVuc2lvbkZyb21Db250ZW50VHlwZShjb250ZW50VHlwZSl9YDtcbiAgICAgICAgcmV0dXJuIHlpZWxkICgwLCByZXF1ZXN0XzEuZGlzcGF0Y2hSZXF1ZXN0KSh7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgdGFyZ2V0VXJsOiBgJHsoMCwgY29uZmlnXzEuZ2V0UmVzdEFwaVVybCkoKX0vc3RvcmFnZS91cGxvYWQvaW5pdGlhdGUtbXVsdGlwYXJ0P3N0b3JhZ2VfdHlwZT1mYWwtY2RuLXYzYCxcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgICAgY29udGVudF90eXBlOiBjb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBmaWxlX25hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwYXJ0VXBsb2FkUmV0cmllcyh1cGxvYWRVcmxfMSwgY2h1bmtfMSwgY29uZmlnXzIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiogKHVwbG9hZFVybCwgY2h1bmssIGNvbmZpZywgdHJpZXMgPSAzKSB7XG4gICAgICAgIGlmICh0cmllcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFydCB1cGxvYWQgZmFpbGVkLCByZXRyaWVzIGV4aGF1c3RlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGZldGNoLCByZXNwb25zZUhhbmRsZXIgfSA9IGNvbmZpZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2godXBsb2FkVXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IGNodW5rLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKHlpZWxkIHJlc3BvbnNlSGFuZGxlcihyZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHBhcnRVcGxvYWRSZXRyaWVzKHVwbG9hZFVybCwgY2h1bmssIGNvbmZpZywgdHJpZXMgLSAxKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gbXVsdGlwYXJ0VXBsb2FkKGZpbGUsIGNvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHsgZmV0Y2gsIHJlc3BvbnNlSGFuZGxlciB9ID0gY29uZmlnO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGZpbGUudHlwZSB8fCBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICBjb25zdCB7IHVwbG9hZF91cmw6IHVwbG9hZFVybCwgZmlsZV91cmw6IHVybCB9ID0geWllbGQgaW5pdGlhdGVNdWx0aXBhcnRVcGxvYWQoZmlsZSwgY29uZmlnLCBjb250ZW50VHlwZSk7XG4gICAgICAgIC8vIEJyZWFrIHRoZSBmaWxlIGludG8gMTBNQiBjaHVua3NcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gMTAgKiAxMDI0ICogMTAyNDtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gTWF0aC5jZWlsKGZpbGUuc2l6ZSAvIGNodW5rU2l6ZSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXBsb2FkVXJsKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaSAqIGNodW5rU2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHN0YXJ0ICsgY2h1bmtTaXplLCBmaWxlLnNpemUpO1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBmaWxlLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgY29uc3QgcGFydE51bWJlciA9IGkgKyAxO1xuICAgICAgICAgICAgLy8ge3VwbG9hZFVybH0ve3BhcnRfbnVtYmVyfT91cGxvYWRVcmxQYXJhbXM9Li4uXG4gICAgICAgICAgICBjb25zdCBwYXJ0VXBsb2FkVXJsID0gYCR7cGFyc2VkVXJsLm9yaWdpbn0ke3BhcnNlZFVybC5wYXRobmFtZX0vJHtwYXJ0TnVtYmVyfSR7cGFyc2VkVXJsLnNlYXJjaH1gO1xuICAgICAgICAgICAgcmVzcG9uc2VzLnB1c2goeWllbGQgcGFydFVwbG9hZFJldHJpZXMocGFydFVwbG9hZFVybCwgY2h1bmssIGNvbmZpZykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXBsZXRlIHRoZSB1cGxvYWRcbiAgICAgICAgY29uc3QgY29tcGxldGVVcmwgPSBgJHtwYXJzZWRVcmwub3JpZ2lufSR7cGFyc2VkVXJsLnBhdGhuYW1lfS9jb21wbGV0ZSR7cGFyc2VkVXJsLnNlYXJjaH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKGNvbXBsZXRlVXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBwYXJ0czogcmVzcG9uc2VzLm1hcCgobXBhcnQpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIHBhcnROdW1iZXI6IG1wYXJ0LnBhcnROdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIGV0YWc6IG1wYXJ0LmV0YWcsXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgICB5aWVsZCByZXNwb25zZUhhbmRsZXIocmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RvcmFnZUNsaWVudCh7IGNvbmZpZywgfSkge1xuICAgIGNvbnN0IHJlZiA9IHtcbiAgICAgICAgdXBsb2FkOiAoZmlsZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIDkwKyBNQiBmaWxlIHNpemUgdG8gZG8gbXVsdGlwYXJ0IHVwbG9hZFxuICAgICAgICAgICAgaWYgKGZpbGUuc2l6ZSA+IDkwICogMTAyNCAqIDEwMjQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgbXVsdGlwYXJ0VXBsb2FkKGZpbGUsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGZpbGUudHlwZSB8fCBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICAgICAgY29uc3QgeyBmZXRjaCwgcmVzcG9uc2VIYW5kbGVyIH0gPSBjb25maWc7XG4gICAgICAgICAgICBjb25zdCB7IHVwbG9hZF91cmw6IHVwbG9hZFVybCwgZmlsZV91cmw6IHVybCB9ID0geWllbGQgaW5pdGlhdGVVcGxvYWQoZmlsZSwgY29uZmlnLCBjb250ZW50VHlwZSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKHVwbG9hZFVybCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgICAgICBib2R5OiBmaWxlLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogZmlsZS50eXBlIHx8IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeWllbGQgcmVzcG9uc2VIYW5kbGVyKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH0pLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB0cmFuc2Zvcm1JbnB1dDogKGlucHV0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaW5wdXQubWFwKChpdGVtKSA9PiByZWYudHJhbnNmb3JtSW5wdXQoaXRlbSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCByZWYudXBsb2FkKGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzUGxhaW5PYmplY3QpKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0T2JqZWN0ID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBPYmplY3QuZW50cmllcyhpbnB1dE9iamVjdCkubWFwKChfYSkgPT4gX19hd2FpdGVyKHRoaXMsIFtfYV0sIHZvaWQgMCwgZnVuY3Rpb24qIChba2V5LCB2YWx1ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtrZXksIHlpZWxkIHJlZi50cmFuc2Zvcm1JbnB1dCh2YWx1ZSldO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0geWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGlucHV0IGFzIGlzIGlmIGl0J3MgbmVpdGhlciBhbiBvYmplY3Qgbm9yIGEgZmlsZS9ibG9iL2RhdGEgVVJJXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH0pLFxuICAgIH07XG4gICAgcmV0dXJuIHJlZjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0b3JhZ2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/storage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/streaming.js":
/*!******************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/streaming.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FalStream = void 0;\nexports.createStreamingClient = createStreamingClient;\nconst eventsource_parser_1 = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.cjs\");\nconst auth_1 = __webpack_require__(/*! ./auth */ \"(rsc)/./node_modules/@fal-ai/client/src/auth.js\");\nconst request_1 = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/@fal-ai/client/src/request.js\");\nconst response_1 = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/@fal-ai/client/src/response.js\");\nconst CONTENT_TYPE_EVENT_STREAM = \"text/event-stream\";\nconst EVENT_STREAM_TIMEOUT = 15 * 1000;\n/**\n * The class representing a streaming response. With t\n */\nclass FalStream {\n    constructor(endpointId, config, options) {\n        var _a;\n        // support for event listeners\n        this.listeners = new Map();\n        this.buffer = [];\n        // local state\n        this.currentData = undefined;\n        this.lastEventTimestamp = 0;\n        this.streamClosed = false;\n        this.abortController = new AbortController();\n        this.start = () => __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            const { endpointId, options } = this;\n            const { input, method = \"post\", connectionMode = \"server\" } = options;\n            try {\n                if (connectionMode === \"client\") {\n                    // if we are in the browser, we need to get a temporary token\n                    // to authenticate the request\n                    const token = yield (0, auth_1.getTemporaryAuthToken)(endpointId, this.config);\n                    const { fetch } = this.config;\n                    const parsedUrl = new URL(this.url);\n                    parsedUrl.searchParams.set(\"fal_jwt_token\", token);\n                    const response = yield fetch(parsedUrl.toString(), {\n                        method: method.toUpperCase(),\n                        headers: {\n                            accept: (_a = options.accept) !== null && _a !== void 0 ? _a : CONTENT_TYPE_EVENT_STREAM,\n                            \"content-type\": \"application/json\",\n                        },\n                        body: input && method !== \"get\" ? JSON.stringify(input) : undefined,\n                        signal: this.abortController.signal,\n                    });\n                    return yield this.handleResponse(response);\n                }\n                return yield (0, request_1.dispatchRequest)({\n                    method: method.toUpperCase(),\n                    targetUrl: this.url,\n                    input,\n                    config: this.config,\n                    options: {\n                        headers: {\n                            accept: (_b = options.accept) !== null && _b !== void 0 ? _b : CONTENT_TYPE_EVENT_STREAM,\n                        },\n                        responseHandler: this.handleResponse,\n                        signal: this.abortController.signal,\n                    },\n                });\n            }\n            catch (error) {\n                this.handleError(error);\n            }\n        });\n        this.handleResponse = (response) => __awaiter(this, void 0, void 0, function* () {\n            var _a, _b;\n            if (!response.ok) {\n                try {\n                    // we know the response failed, call the response handler\n                    // so the exception gets converted to ApiError correctly\n                    yield (0, response_1.defaultResponseHandler)(response);\n                }\n                catch (error) {\n                    this.emit(\"error\", error);\n                }\n                return;\n            }\n            const body = response.body;\n            if (!body) {\n                this.emit(\"error\", new response_1.ApiError({\n                    message: \"Response body is empty.\",\n                    status: 400,\n                    body: undefined,\n                }));\n                return;\n            }\n            const isEventStream = ((_a = response.headers.get(\"content-type\")) !== null && _a !== void 0 ? _a : \"\").startsWith(CONTENT_TYPE_EVENT_STREAM);\n            // any response that is not a text/event-stream will be handled as a binary stream\n            if (!isEventStream) {\n                const reader = body.getReader();\n                const emitRawChunk = () => {\n                    reader.read().then(({ done, value }) => {\n                        if (done) {\n                            this.emit(\"done\", this.currentData);\n                            return;\n                        }\n                        this.currentData = value;\n                        this.emit(\"data\", value);\n                        emitRawChunk();\n                    });\n                };\n                emitRawChunk();\n                return;\n            }\n            const decoder = new TextDecoder(\"utf-8\");\n            const reader = response.body.getReader();\n            const parser = (0, eventsource_parser_1.createParser)((event) => {\n                if (event.type === \"event\") {\n                    const data = event.data;\n                    try {\n                        const parsedData = JSON.parse(data);\n                        this.buffer.push(parsedData);\n                        this.currentData = parsedData;\n                        this.emit(\"data\", parsedData);\n                        // also emit 'message'for backwards compatibility\n                        this.emit(\"message\", parsedData);\n                    }\n                    catch (e) {\n                        this.emit(\"error\", e);\n                    }\n                }\n            });\n            const timeout = (_b = this.options.timeout) !== null && _b !== void 0 ? _b : EVENT_STREAM_TIMEOUT;\n            const readPartialResponse = () => __awaiter(this, void 0, void 0, function* () {\n                const { value, done } = yield reader.read();\n                this.lastEventTimestamp = Date.now();\n                parser.feed(decoder.decode(value));\n                if (Date.now() - this.lastEventTimestamp > timeout) {\n                    this.emit(\"error\", new response_1.ApiError({\n                        message: `Event stream timed out after ${(timeout / 1000).toFixed(0)} seconds with no messages.`,\n                        status: 408,\n                    }));\n                }\n                if (!done) {\n                    readPartialResponse().catch(this.handleError);\n                }\n                else {\n                    this.emit(\"done\", this.currentData);\n                }\n            });\n            readPartialResponse().catch(this.handleError);\n            return;\n        });\n        this.handleError = (error) => {\n            var _a;\n            // In case AbortError is thrown but the signal is marked as aborted\n            // it means the user called abort() and we should not emit an error\n            // as it's expected behavior\n            // See note on: https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort\n            if (error.name === \"AbortError\" || this.signal.aborted) {\n                return;\n            }\n            const apiError = error instanceof response_1.ApiError\n                ? error\n                : new response_1.ApiError({\n                    message: (_a = error.message) !== null && _a !== void 0 ? _a : \"An unknown error occurred\",\n                    status: 500,\n                });\n            this.emit(\"error\", apiError);\n            return;\n        };\n        this.on = (type, listener) => {\n            var _a;\n            if (!this.listeners.has(type)) {\n                this.listeners.set(type, []);\n            }\n            (_a = this.listeners.get(type)) === null || _a === void 0 ? void 0 : _a.push(listener);\n        };\n        this.emit = (type, event) => {\n            const listeners = this.listeners.get(type) || [];\n            for (const listener of listeners) {\n                listener(event);\n            }\n        };\n        /**\n         * Gets a reference to the `Promise` that indicates whether the streaming\n         * is done or not. Developers should always call this in their apps to ensure\n         * the request is over.\n         *\n         * An alternative to this, is to use `on('done')` in case your application\n         * architecture works best with event listeners.\n         *\n         * @returns the promise that resolves when the request is done.\n         */\n        this.done = () => __awaiter(this, void 0, void 0, function* () { return this.donePromise; });\n        /**\n         * Aborts the streaming request.\n         *\n         * **Note:** This method is noop in case the request is already done.\n         *\n         * @param reason optional cause for aborting the request.\n         */\n        this.abort = (reason) => {\n            if (!this.streamClosed) {\n                this.abortController.abort(reason);\n            }\n        };\n        this.endpointId = endpointId;\n        this.config = config;\n        this.url =\n            (_a = options.url) !== null && _a !== void 0 ? _a : (0, request_1.buildUrl)(endpointId, {\n                path: \"/stream\",\n                query: options.queryParams,\n            });\n        this.options = options;\n        this.donePromise = new Promise((resolve, reject) => {\n            if (this.streamClosed) {\n                reject(new response_1.ApiError({\n                    message: \"Streaming connection is already closed.\",\n                    status: 400,\n                    body: undefined,\n                }));\n            }\n            this.signal.addEventListener(\"abort\", () => {\n                var _a;\n                resolve((_a = this.currentData) !== null && _a !== void 0 ? _a : {});\n            });\n            this.on(\"done\", (data) => {\n                this.streamClosed = true;\n                resolve(data);\n            });\n            this.on(\"error\", (error) => {\n                this.streamClosed = true;\n                reject(error);\n            });\n        });\n        // if a abort signal was passed, sync it with the internal one\n        if (options.signal) {\n            options.signal.addEventListener(\"abort\", () => {\n                this.abortController.abort();\n            });\n        }\n        // start the streaming request\n        this.start().catch(this.handleError);\n    }\n    [Symbol.asyncIterator]() {\n        return __asyncGenerator(this, arguments, function* _a() {\n            let running = true;\n            const stopAsyncIterator = () => (running = false);\n            this.on(\"error\", stopAsyncIterator);\n            this.on(\"done\", stopAsyncIterator);\n            while (running || this.buffer.length > 0) {\n                const data = this.buffer.shift();\n                if (data) {\n                    yield yield __await(data);\n                }\n                // the short timeout ensures the while loop doesn't block other\n                // frames getting executed concurrently\n                yield __await(new Promise((resolve) => setTimeout(resolve, 16)));\n            }\n        });\n    }\n    /**\n     * Gets the `AbortSignal` instance that can be used to listen for abort events.\n     *\n     * **Note:** this signal is internal to the `FalStream` instance. If you pass your\n     * own abort signal, the `FalStream` will listen to it and abort it appropriately.\n     *\n     * @returns the `AbortSignal` instance.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\n     */\n    get signal() {\n        return this.abortController.signal;\n    }\n}\nexports.FalStream = FalStream;\nfunction createStreamingClient({ config, storage, }) {\n    return {\n        stream(endpointId, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const input = options.input\n                    ? yield storage.transformInput(options.input)\n                    : undefined;\n                return new FalStream(endpointId, config, Object.assign(Object.assign({}, options), { input: input }));\n            });\n        },\n    };\n}\n//# sourceMappingURL=streaming.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3N0cmVhbWluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9HQUFvRyxjQUFjO0FBQ25JLDhCQUE4QixzQkFBc0I7QUFDcEQsMEJBQTBCLFlBQVksc0JBQXNCLHFDQUFxQywyQ0FBMkMsTUFBTTtBQUNsSiw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLDZCQUE2QjtBQUM3Qiw2QkFBNkIsbUJBQU8sQ0FBQyxrRkFBb0I7QUFDekQsZUFBZSxtQkFBTyxDQUFDLCtEQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLHFFQUFXO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLHVFQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUMsb0JBQW9CLG9EQUFvRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsNkJBQTZCO0FBQzlGO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDBCQUEwQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGNBQWMsY0FBYztBQUNuSCxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbXBsYXRlLTIvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3N0cmVhbWluZy5qcz9kODNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19hd2FpdCA9ICh0aGlzICYmIHRoaXMuX19hd2FpdCkgfHwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7IH1cbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jR2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiwgYXdhaXRSZXR1cm4pLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gICAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GYWxTdHJlYW0gPSB2b2lkIDA7XG5leHBvcnRzLmNyZWF0ZVN0cmVhbWluZ0NsaWVudCA9IGNyZWF0ZVN0cmVhbWluZ0NsaWVudDtcbmNvbnN0IGV2ZW50c291cmNlX3BhcnNlcl8xID0gcmVxdWlyZShcImV2ZW50c291cmNlLXBhcnNlclwiKTtcbmNvbnN0IGF1dGhfMSA9IHJlcXVpcmUoXCIuL2F1dGhcIik7XG5jb25zdCByZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi9yZXF1ZXN0XCIpO1xuY29uc3QgcmVzcG9uc2VfMSA9IHJlcXVpcmUoXCIuL3Jlc3BvbnNlXCIpO1xuY29uc3QgQ09OVEVOVF9UWVBFX0VWRU5UX1NUUkVBTSA9IFwidGV4dC9ldmVudC1zdHJlYW1cIjtcbmNvbnN0IEVWRU5UX1NUUkVBTV9USU1FT1VUID0gMTUgKiAxMDAwO1xuLyoqXG4gKiBUaGUgY2xhc3MgcmVwcmVzZW50aW5nIGEgc3RyZWFtaW5nIHJlc3BvbnNlLiBXaXRoIHRcbiAqL1xuY2xhc3MgRmFsU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihlbmRwb2ludElkLCBjb25maWcsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBzdXBwb3J0IGZvciBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIC8vIGxvY2FsIHN0YXRlXG4gICAgICAgIHRoaXMuY3VycmVudERhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGFzdEV2ZW50VGltZXN0YW1wID0gMDtcbiAgICAgICAgdGhpcy5zdHJlYW1DbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIHRoaXMuc3RhcnQgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgeyBlbmRwb2ludElkLCBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBpbnB1dCwgbWV0aG9kID0gXCJwb3N0XCIsIGNvbm5lY3Rpb25Nb2RlID0gXCJzZXJ2ZXJcIiB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25Nb2RlID09PSBcImNsaWVudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBpbiB0aGUgYnJvd3Nlciwgd2UgbmVlZCB0byBnZXQgYSB0ZW1wb3JhcnkgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXV0aGVudGljYXRlIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuID0geWllbGQgKDAsIGF1dGhfMS5nZXRUZW1wb3JhcnlBdXRoVG9rZW4pKGVuZHBvaW50SWQsIHRoaXMuY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmZXRjaCB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodGhpcy51cmwpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRVcmwuc2VhcmNoUGFyYW1zLnNldChcImZhbF9qd3RfdG9rZW5cIiwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKHBhcnNlZFVybC50b1N0cmluZygpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdDogKF9hID0gb3B0aW9ucy5hY2NlcHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IENPTlRFTlRfVFlQRV9FVkVOVF9TVFJFQU0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogaW5wdXQgJiYgbWV0aG9kICE9PSBcImdldFwiID8gSlNPTi5zdHJpbmdpZnkoaW5wdXQpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5oYW5kbGVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCAoMCwgcmVxdWVzdF8xLmRpc3BhdGNoUmVxdWVzdCkoe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRVcmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VwdDogKF9iID0gb3B0aW9ucy5hY2NlcHQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IENPTlRFTlRfVFlQRV9FVkVOVF9TVFJFQU0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VIYW5kbGVyOiB0aGlzLmhhbmRsZVJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzcG9uc2UgPSAocmVzcG9uc2UpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2Uga25vdyB0aGUgcmVzcG9uc2UgZmFpbGVkLCBjYWxsIHRoZSByZXNwb25zZSBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHRoZSBleGNlcHRpb24gZ2V0cyBjb252ZXJ0ZWQgdG8gQXBpRXJyb3IgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkICgwLCByZXNwb25zZV8xLmRlZmF1bHRSZXNwb25zZUhhbmRsZXIpKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYm9keSA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBuZXcgcmVzcG9uc2VfMS5BcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiUmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIixcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiA0MDAsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNFdmVudFN0cmVhbSA9ICgoX2EgPSByZXNwb25zZS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIikuc3RhcnRzV2l0aChDT05URU5UX1RZUEVfRVZFTlRfU1RSRUFNKTtcbiAgICAgICAgICAgIC8vIGFueSByZXNwb25zZSB0aGF0IGlzIG5vdCBhIHRleHQvZXZlbnQtc3RyZWFtIHdpbGwgYmUgaGFuZGxlZCBhcyBhIGJpbmFyeSBzdHJlYW1cbiAgICAgICAgICAgIGlmICghaXNFdmVudFN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IGJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW1pdFJhd0NodW5rID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVhZCgpLnRoZW4oKHsgZG9uZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkb25lXCIsIHRoaXMuY3VycmVudERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERhdGEgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdFJhd0NodW5rKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZW1pdFJhd0NodW5rKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9ICgwLCBldmVudHNvdXJjZV9wYXJzZXJfMS5jcmVhdGVQYXJzZXIpKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2gocGFyc2VkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRhID0gcGFyc2VkRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgcGFyc2VkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGVtaXQgJ21lc3NhZ2UnZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIHBhcnNlZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IChfYiA9IHRoaXMub3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBFVkVOVF9TVFJFQU1fVElNRU9VVDtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRQYXJ0aWFsUmVzcG9uc2UgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0geWllbGQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RFdmVudFRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmZlZWQoZGVjb2Rlci5kZWNvZGUodmFsdWUpKTtcbiAgICAgICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHRoaXMubGFzdEV2ZW50VGltZXN0YW1wID4gdGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBuZXcgcmVzcG9uc2VfMS5BcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRXZlbnQgc3RyZWFtIHRpbWVkIG91dCBhZnRlciAkeyh0aW1lb3V0IC8gMTAwMCkudG9GaXhlZCgwKX0gc2Vjb25kcyB3aXRoIG5vIG1lc3NhZ2VzLmAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDQwOCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZFBhcnRpYWxSZXNwb25zZSgpLmNhdGNoKHRoaXMuaGFuZGxlRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZG9uZVwiLCB0aGlzLmN1cnJlbnREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlYWRQYXJ0aWFsUmVzcG9uc2UoKS5jYXRjaCh0aGlzLmhhbmRsZUVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIC8vIEluIGNhc2UgQWJvcnRFcnJvciBpcyB0aHJvd24gYnV0IHRoZSBzaWduYWwgaXMgbWFya2VkIGFzIGFib3J0ZWRcbiAgICAgICAgICAgIC8vIGl0IG1lYW5zIHRoZSB1c2VyIGNhbGxlZCBhYm9ydCgpIGFuZCB3ZSBzaG91bGQgbm90IGVtaXQgYW4gZXJyb3JcbiAgICAgICAgICAgIC8vIGFzIGl0J3MgZXhwZWN0ZWQgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vIFNlZSBub3RlIG9uOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQWJvcnRDb250cm9sbGVyL2Fib3J0XG4gICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIgfHwgdGhpcy5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaUVycm9yID0gZXJyb3IgaW5zdGFuY2VvZiByZXNwb25zZV8xLkFwaUVycm9yXG4gICAgICAgICAgICAgICAgPyBlcnJvclxuICAgICAgICAgICAgICAgIDogbmV3IHJlc3BvbnNlXzEuQXBpRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAoX2EgPSBlcnJvci5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWRcIixcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBhcGlFcnJvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub24gPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnMuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuc2V0KHR5cGUsIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYSA9IHRoaXMubGlzdGVuZXJzLmdldCh0eXBlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVtaXQgPSAodHlwZSwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzLmdldCh0eXBlKSB8fCBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhIHJlZmVyZW5jZSB0byB0aGUgYFByb21pc2VgIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN0cmVhbWluZ1xuICAgICAgICAgKiBpcyBkb25lIG9yIG5vdC4gRGV2ZWxvcGVycyBzaG91bGQgYWx3YXlzIGNhbGwgdGhpcyBpbiB0aGVpciBhcHBzIHRvIGVuc3VyZVxuICAgICAgICAgKiB0aGUgcmVxdWVzdCBpcyBvdmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byB0aGlzLCBpcyB0byB1c2UgYG9uKCdkb25lJylgIGluIGNhc2UgeW91ciBhcHBsaWNhdGlvblxuICAgICAgICAgKiBhcmNoaXRlY3R1cmUgd29ya3MgYmVzdCB3aXRoIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgdGhlIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSByZXF1ZXN0IGlzIGRvbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvbmUgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7IHJldHVybiB0aGlzLmRvbmVQcm9taXNlOyB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFib3J0cyB0aGUgc3RyZWFtaW5nIHJlcXVlc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBub29wIGluIGNhc2UgdGhlIHJlcXVlc3QgaXMgYWxyZWFkeSBkb25lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcmVhc29uIG9wdGlvbmFsIGNhdXNlIGZvciBhYm9ydGluZyB0aGUgcmVxdWVzdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWJvcnQgPSAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RyZWFtQ2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbmRwb2ludElkID0gZW5kcG9pbnRJZDtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMudXJsID1cbiAgICAgICAgICAgIChfYSA9IG9wdGlvbnMudXJsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoMCwgcmVxdWVzdF8xLmJ1aWxkVXJsKShlbmRwb2ludElkLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogXCIvc3RyZWFtXCIsXG4gICAgICAgICAgICAgICAgcXVlcnk6IG9wdGlvbnMucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5kb25lUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmVhbUNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgcmVzcG9uc2VfMS5BcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiU3RyZWFtaW5nIGNvbm5lY3Rpb24gaXMgYWxyZWFkeSBjbG9zZWQuXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogNDAwLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgoX2EgPSB0aGlzLmN1cnJlbnREYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMub24oXCJkb25lXCIsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1DbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbUNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gaWYgYSBhYm9ydCBzaWduYWwgd2FzIHBhc3NlZCwgc3luYyBpdCB3aXRoIHRoZSBpbnRlcm5hbCBvbmVcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGFydCB0aGUgc3RyZWFtaW5nIHJlcXVlc3RcbiAgICAgICAgdGhpcy5zdGFydCgpLmNhdGNoKHRoaXMuaGFuZGxlRXJyb3IpO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBfYSgpIHtcbiAgICAgICAgICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHN0b3BBc3luY0l0ZXJhdG9yID0gKCkgPT4gKHJ1bm5pbmcgPSBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLm9uKFwiZXJyb3JcIiwgc3RvcEFzeW5jSXRlcmF0b3IpO1xuICAgICAgICAgICAgdGhpcy5vbihcImRvbmVcIiwgc3RvcEFzeW5jSXRlcmF0b3IpO1xuICAgICAgICAgICAgd2hpbGUgKHJ1bm5pbmcgfHwgdGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmJ1ZmZlci5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoZSBzaG9ydCB0aW1lb3V0IGVuc3VyZXMgdGhlIHdoaWxlIGxvb3AgZG9lc24ndCBibG9jayBvdGhlclxuICAgICAgICAgICAgICAgIC8vIGZyYW1lcyBnZXR0aW5nIGV4ZWN1dGVkIGNvbmN1cnJlbnRseVxuICAgICAgICAgICAgICAgIHlpZWxkIF9fYXdhaXQobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTYpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBgQWJvcnRTaWduYWxgIGluc3RhbmNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gbGlzdGVuIGZvciBhYm9ydCBldmVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogdGhpcyBzaWduYWwgaXMgaW50ZXJuYWwgdG8gdGhlIGBGYWxTdHJlYW1gIGluc3RhbmNlLiBJZiB5b3UgcGFzcyB5b3VyXG4gICAgICogb3duIGFib3J0IHNpZ25hbCwgdGhlIGBGYWxTdHJlYW1gIHdpbGwgbGlzdGVuIHRvIGl0IGFuZCBhYm9ydCBpdCBhcHByb3ByaWF0ZWx5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIGBBYm9ydFNpZ25hbGAgaW5zdGFuY2UuXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQWJvcnRTaWduYWxcbiAgICAgKi9cbiAgICBnZXQgc2lnbmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgIH1cbn1cbmV4cG9ydHMuRmFsU3RyZWFtID0gRmFsU3RyZWFtO1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtaW5nQ2xpZW50KHsgY29uZmlnLCBzdG9yYWdlLCB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RyZWFtKGVuZHBvaW50SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBvcHRpb25zLmlucHV0XG4gICAgICAgICAgICAgICAgICAgID8geWllbGQgc3RvcmFnZS50cmFuc2Zvcm1JbnB1dChvcHRpb25zLmlucHV0KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhbFN0cmVhbShlbmRwb2ludElkLCBjb25maWcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgaW5wdXQ6IGlucHV0IH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJlYW1pbmcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/streaming.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/types/common.js":
/*!*********************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/types/common.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isQueueStatus = isQueueStatus;\nexports.isCompletedQueueStatus = isCompletedQueueStatus;\nfunction isQueueStatus(obj) {\n    return obj && obj.status && obj.response_url;\n}\nfunction isCompletedQueueStatus(obj) {\n    return isQueueStatus(obj) && obj.status === \"COMPLETED\";\n}\n//# sourceMappingURL=common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3R5cGVzL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVtcGxhdGUtMi8uL25vZGVfbW9kdWxlcy9AZmFsLWFpL2NsaWVudC9zcmMvdHlwZXMvY29tbW9uLmpzPzllMDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzUXVldWVTdGF0dXMgPSBpc1F1ZXVlU3RhdHVzO1xuZXhwb3J0cy5pc0NvbXBsZXRlZFF1ZXVlU3RhdHVzID0gaXNDb21wbGV0ZWRRdWV1ZVN0YXR1cztcbmZ1bmN0aW9uIGlzUXVldWVTdGF0dXMob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouc3RhdHVzICYmIG9iai5yZXNwb25zZV91cmw7XG59XG5mdW5jdGlvbiBpc0NvbXBsZXRlZFF1ZXVlU3RhdHVzKG9iaikge1xuICAgIHJldHVybiBpc1F1ZXVlU3RhdHVzKG9iaikgJiYgb2JqLnN0YXR1cyA9PT0gXCJDT01QTEVURURcIjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1vbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/types/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/src/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/@fal-ai/client/src/utils.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ensureEndpointIdFormat = ensureEndpointIdFormat;\nexports.parseEndpointId = parseEndpointId;\nexports.isValidUrl = isValidUrl;\nexports.throttle = throttle;\nexports.isReact = isReact;\nexports.isPlainObject = isPlainObject;\nfunction ensureEndpointIdFormat(id) {\n    const parts = id.split(\"/\");\n    if (parts.length > 1) {\n        return id;\n    }\n    const [, appOwner, appId] = /^([0-9]+)-([a-zA-Z0-9-]+)$/.exec(id) || [];\n    if (appOwner && appId) {\n        return `${appOwner}/${appId}`;\n    }\n    throw new Error(`Invalid app id: ${id}. Must be in the format <appOwner>/<appId>`);\n}\nconst ENDPOINT_NAMESPACES = [\"workflows\", \"comfy\"];\nfunction parseEndpointId(id) {\n    const normalizedId = ensureEndpointIdFormat(id);\n    const parts = normalizedId.split(\"/\");\n    if (ENDPOINT_NAMESPACES.includes(parts[0])) {\n        return {\n            owner: parts[1],\n            alias: parts[2],\n            path: parts.slice(3).join(\"/\") || undefined,\n            namespace: parts[0],\n        };\n    }\n    return {\n        owner: parts[0],\n        alias: parts[1],\n        path: parts.slice(2).join(\"/\") || undefined,\n    };\n}\nfunction isValidUrl(url) {\n    try {\n        const { host } = new URL(url);\n        return /(fal\\.(ai|run))$/.test(host);\n    }\n    catch (_) {\n        return false;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction throttle(func, limit, leading = false) {\n    let lastFunc;\n    let lastRan;\n    return (...args) => {\n        if (!lastRan && leading) {\n            func(...args);\n            lastRan = Date.now();\n        }\n        else {\n            if (lastFunc) {\n                clearTimeout(lastFunc);\n            }\n            lastFunc = setTimeout(() => {\n                if (Date.now() - lastRan >= limit) {\n                    func(...args);\n                    lastRan = Date.now();\n                }\n            }, limit - (Date.now() - lastRan));\n        }\n    };\n}\nlet isRunningInReact;\n/**\n * Not really the most optimal way to detect if we're running in React,\n * but the idea here is that we can support multiple rendering engines\n * (starting with React), with all their peculiarities, without having\n * to add a dependency or creating custom integrations (e.g. custom hooks).\n *\n * Yes, a bit of magic to make things works out-of-the-box.\n * @returns `true` if running in React, `false` otherwise.\n */\nfunction isReact() {\n    if (isRunningInReact === undefined) {\n        const stack = new Error().stack;\n        isRunningInReact =\n            !!stack &&\n                (stack.includes(\"node_modules/react-dom/\") ||\n                    stack.includes(\"node_modules/next/\"));\n    }\n    return isRunningInReact;\n}\n/**\n * Check if a value is a plain object.\n * @param value - The value to check.\n * @returns `true` if the value is a plain object, `false` otherwise.\n */\nfunction isPlainObject(value) {\n    return !!value && Object.getPrototypeOf(value) === Object.prototype;\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGZhbC1haS9jbGllbnQvc3JjL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5Qix1QkFBdUI7QUFDdkIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVMsR0FBRyxNQUFNO0FBQ3BDO0FBQ0EsdUNBQXVDLEdBQUc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZW1wbGF0ZS0yLy4vbm9kZV9tb2R1bGVzL0BmYWwtYWkvY2xpZW50L3NyYy91dGlscy5qcz9iOTg4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbnN1cmVFbmRwb2ludElkRm9ybWF0ID0gZW5zdXJlRW5kcG9pbnRJZEZvcm1hdDtcbmV4cG9ydHMucGFyc2VFbmRwb2ludElkID0gcGFyc2VFbmRwb2ludElkO1xuZXhwb3J0cy5pc1ZhbGlkVXJsID0gaXNWYWxpZFVybDtcbmV4cG9ydHMudGhyb3R0bGUgPSB0aHJvdHRsZTtcbmV4cG9ydHMuaXNSZWFjdCA9IGlzUmVhY3Q7XG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuZnVuY3Rpb24gZW5zdXJlRW5kcG9pbnRJZEZvcm1hdChpZCkge1xuICAgIGNvbnN0IHBhcnRzID0gaWQuc3BsaXQoXCIvXCIpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgY29uc3QgWywgYXBwT3duZXIsIGFwcElkXSA9IC9eKFswLTldKyktKFthLXpBLVowLTktXSspJC8uZXhlYyhpZCkgfHwgW107XG4gICAgaWYgKGFwcE93bmVyICYmIGFwcElkKSB7XG4gICAgICAgIHJldHVybiBgJHthcHBPd25lcn0vJHthcHBJZH1gO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXBwIGlkOiAke2lkfS4gTXVzdCBiZSBpbiB0aGUgZm9ybWF0IDxhcHBPd25lcj4vPGFwcElkPmApO1xufVxuY29uc3QgRU5EUE9JTlRfTkFNRVNQQUNFUyA9IFtcIndvcmtmbG93c1wiLCBcImNvbWZ5XCJdO1xuZnVuY3Rpb24gcGFyc2VFbmRwb2ludElkKGlkKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZElkID0gZW5zdXJlRW5kcG9pbnRJZEZvcm1hdChpZCk7XG4gICAgY29uc3QgcGFydHMgPSBub3JtYWxpemVkSWQuc3BsaXQoXCIvXCIpO1xuICAgIGlmIChFTkRQT0lOVF9OQU1FU1BBQ0VTLmluY2x1ZGVzKHBhcnRzWzBdKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3duZXI6IHBhcnRzWzFdLFxuICAgICAgICAgICAgYWxpYXM6IHBhcnRzWzJdLFxuICAgICAgICAgICAgcGF0aDogcGFydHMuc2xpY2UoMykuam9pbihcIi9cIikgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiBwYXJ0c1swXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3duZXI6IHBhcnRzWzBdLFxuICAgICAgICBhbGlhczogcGFydHNbMV0sXG4gICAgICAgIHBhdGg6IHBhcnRzLnNsaWNlKDIpLmpvaW4oXCIvXCIpIHx8IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNWYWxpZFVybCh1cmwpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgcmV0dXJuIC8oZmFsXFwuKGFpfHJ1bikpJC8udGVzdChob3N0KTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCBsaW1pdCwgbGVhZGluZyA9IGZhbHNlKSB7XG4gICAgbGV0IGxhc3RGdW5jO1xuICAgIGxldCBsYXN0UmFuO1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoIWxhc3RSYW4gJiYgbGVhZGluZykge1xuICAgICAgICAgICAgZnVuYyguLi5hcmdzKTtcbiAgICAgICAgICAgIGxhc3RSYW4gPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxhc3RGdW5jKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGxhc3RGdW5jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RGdW5jID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKERhdGUubm93KCkgLSBsYXN0UmFuID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmMoLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RSYW4gPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGxpbWl0IC0gKERhdGUubm93KCkgLSBsYXN0UmFuKSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxubGV0IGlzUnVubmluZ0luUmVhY3Q7XG4vKipcbiAqIE5vdCByZWFsbHkgdGhlIG1vc3Qgb3B0aW1hbCB3YXkgdG8gZGV0ZWN0IGlmIHdlJ3JlIHJ1bm5pbmcgaW4gUmVhY3QsXG4gKiBidXQgdGhlIGlkZWEgaGVyZSBpcyB0aGF0IHdlIGNhbiBzdXBwb3J0IG11bHRpcGxlIHJlbmRlcmluZyBlbmdpbmVzXG4gKiAoc3RhcnRpbmcgd2l0aCBSZWFjdCksIHdpdGggYWxsIHRoZWlyIHBlY3VsaWFyaXRpZXMsIHdpdGhvdXQgaGF2aW5nXG4gKiB0byBhZGQgYSBkZXBlbmRlbmN5IG9yIGNyZWF0aW5nIGN1c3RvbSBpbnRlZ3JhdGlvbnMgKGUuZy4gY3VzdG9tIGhvb2tzKS5cbiAqXG4gKiBZZXMsIGEgYml0IG9mIG1hZ2ljIHRvIG1ha2UgdGhpbmdzIHdvcmtzIG91dC1vZi10aGUtYm94LlxuICogQHJldHVybnMgYHRydWVgIGlmIHJ1bm5pbmcgaW4gUmVhY3QsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1JlYWN0KCkge1xuICAgIGlmIChpc1J1bm5pbmdJblJlYWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICAgICAgaXNSdW5uaW5nSW5SZWFjdCA9XG4gICAgICAgICAgICAhIXN0YWNrICYmXG4gICAgICAgICAgICAgICAgKHN0YWNrLmluY2x1ZGVzKFwibm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9cIikgfHxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2suaW5jbHVkZXMoXCJub2RlX21vZHVsZXMvbmV4dC9cIikpO1xuICAgIH1cbiAgICByZXR1cm4gaXNSdW5uaW5nSW5SZWFjdDtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@fal-ai/client/src/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@fal-ai/client/package.json":
/*!**************************************************!*\
  !*** ./node_modules/@fal-ai/client/package.json ***!
  \**************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"@fal-ai/client","description":"The fal.ai client for JavaScript and TypeScript","version":"1.3.0","license":"MIT","repository":{"type":"git","url":"https://github.com/fal-ai/fal-js.git","directory":"libs/client"},"keywords":["fal","client","ai","ml","typescript"],"exports":{".":"./src/index.js","./endpoints":"./src/types/endpoints.js"},"typesVersions":{"*":{"endpoints":["src/types/endpoints.d.ts"]}},"main":"./src/index.js","types":"./src/index.d.ts","dependencies":{"@msgpack/msgpack":"^3.0.0-beta2","eventsource-parser":"^1.1.2","robot3":"^0.4.1"},"engines":{"node":">=18.0.0"},"type":"commonjs"}');

/***/ })

};
;